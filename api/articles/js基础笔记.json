{"title":"JS基础笔记","slug":"js基础笔记","date":"2017-01-02T10:10:00.000Z","updated":"2018-12-06T06:28:17.923Z","comments":true,"excerpt":"","content":"<pre>\n        数据类型6种\n        string, number, null的数据类型为object(历史原因),  undefined的数据类型还是它， boolean, object\n     命名规范\n            1. 必须以$_英文字母开头， $_英文字母和数字\n            2. 不可以使用关键字或者保留字\n    \n    // 布尔类型的转换Boolean()\n                数字转为布尔类型，除了0全为真\n        字符串转为布尔类型，在非空字符串都为真。\n        null, undefined 转化为布尔都为假\n    // 其他类型转为字符串xxx.toString()：\n        数字，布尔类型可以转换为字符串类型。其他报错。\n    //转换为数字类型 1. Number()   2. parseInt()  3. parseFloat()\n                Number 只能转换数字字符串。数字字符串： 字符串的内容为纯数字。空字符串、空格、null转换为0；undefined、(11aa)是NaN\n         parseInt， parseFloat: 字符串必须以数字开头，找到第一个非数字结束。 前者会返回一个整数，向下取整。后者会返回一个浮点数。\n    \n     // 1. 10进制准换位其他进制\n                var  a= 100;\n               console.log(a.toString(8));\n        通过xxx..toString() 括号内传入数字，想转换为几进制，就写数字几， 返回结果为字符串\n     // 2. 其他进制转换10进制\n         var a = 1010;\n              console.log(parseInt(a, 8));\n        通过parseInt();写一个变量，然后逗号，最后变量是多少进制就写多少进制\n    \n    // 算术运算符：+ - * / %\n    // 赋值运算符：= += *= -= /= %=\n    // 逻辑运算符： ! && ||\n         && 有一假即返回， 如果都为真，返回最后一个结果\n         || 有一真即返回，如果都为假，返回最后一个结果\n    // 一元运算符 ++ --\n                ++前置: 在本次运算中，变量执行+1操作\n        后置++： 下次使用时，变量进行+1操作\n    // 三元运算符? :\n                var c = 10 == 10 ? '123' : '456';\n    // 关系运算符：==,!=, !==(等于，直接比较值), ===(恒等于,先比较数据类型，在比较值。), >, <, <=\",\">=\n        \n    //隐式转换\n        + : 1.如果有一者为字符串，另外一个会进行隐士转换为字符串（相当于字符串拼接）\n                          2. 如果没有字符串，其他类型隐士转换为数字类型的（不包含对象） \n         - * / % : 默认将元素进行隐士转换，转换为数字。\n        == === != !== > < >= <=（关系运算符） 1=\"\" 8080=\"\" ==\"=\" 恒等于不会进行隐士转换=\"\" 1.=\"\" 如果有数字的话，=\"\" 默认都转化为数字=\"\" 2.=\"\" 如果有布尔类型，=\"\" 先把布尔类型转化为数字=\"\" (不适用在=\"=\" 中的null，=\"\" 和undefined);=\"\" 结论：=\"\" null=\"\" 跟=\"\" undefined=\"\" 两者互相相等，=\"\" 而且等于本身，=\"\" 其他的值都不相等。=\"\" 掌握nan的含义=\"\" 答：=\"\" 1.不是一个数字。=\"\" 2.是number类型的=\"\" 3.=\"\" nan不等于任何值，包括本身。=\"\" 思考isnan()的使用方法？=\"\" 1.判断括号内的内容是否为nan,如果是返回true，如果不是返回false。=\"\" 括号内的内容会默认进行隐士转换，转换为number.=\"\" tofixed()保留小数，括号内传入一个数字，代表保留的位数。返回一个字符串。=\"\" 提示框（alert），=\"\" 只有一个确定按钮，=\"\" 没有返回值=\"\" 对话框(prompt)=\"\" 点击确定：返回输入的内容，=\"\" 且是字符串类型的=\"\" 点击取消：返回null=\"\" 确认框(confirm)=\"\" 点击确定：=\"\" 返回true=\"\" 点击取消：=\"\" 返回false=\"\" 缺点：=\"\" 不可以修改样式=\"\" 阻塞进程=\"\" 返回一个min=\"\" -=\"\" max=\"\" 的随机整数=\"\" var=\"\" d=\"min\" +=\"\" math.random()=\"\" *=\"\" (max=\"\" min);=\"\" debugger=\"\" 打断点=\"\" switch:=\"\" 匹配值的时候，是恒等于。=\"\" default：如果没有值可以匹配的话，默认执行default后面的代码（相当于if语句中的else）=\"\" case穿透：如果条件满足，后面的代码都会执行，直到遇见break，才会终止=\"\" 获取绝对值:math.abs=\"\" 向下取整:math.floor=\"\" 向上取整:math.ceil=\"\" 四舍五入:math.round=\"\" 获取随机数:math.random();=\"\" 循环：同一件事情重复去做=\"\" 死循环：同一件事情不停的做，=\"\" 没有出口(浏览器崩溃)；=\"\" continue:=\"\" 跳出当前这一步循环，后面的继续=\"\" break:=\"\" 终止当前这个循环，=\"\" 其他的循环不在继续。=\"\" 无论条件是否满足，至少执行一次=\"\" do=\"\" {=\"\" }=\"\" while(条件)=\"\" 1.声明变量有哪些规则？=\"\" 必须以$_英文字母开头=\"\" 组成部分只能是$_英文字母和数字=\"\" 不能使用关键字和保留字=\"\" 2.强制转换有哪几种？=\"\" 转字符串：=\"\" xxx.tostring()=\"\" 注意：=\"\" null和undefined=\"\" 不可以强制转换。=\"\" 转数字：=\"\" number(),=\"\" parseint(),=\"\" parsefloat()=\"\" 转布尔类型：=\"\" boolean()=\"\" parsefloat()转字符串时三者的区别？=\"\" number()只能转数字字符串，整数浮点数都可以，其他的不行=\"\" parsefloat()可以转以数字开头的字符串，到第一个不为数字的字符结束=\"\" parseint()只能转整型,=\"\" parsefloat()可以是浮点数=\"\" 浏览器三个弹窗=\"\" 1.alert()=\"\" prompt()=\"\" confirm()=\"\" 4.=\"\" switch语句中的break关键字有什么作用？=\"\" 1.break会终止switch语句。=\"\" 2.如果不加break，可能会造成case穿透：即只要有一个case满足条件，后面的代码都会执行，无论条件是否成立=\"\" 5.=\"\" 循环体中的break有什么作用？continue有什么作用？=\"\" 终止当前循环体，所有循环都将停止=\"\" continue：=\"\" 跳过这一步循环，其他循环继续。=\"\" 函数=\"\" ：=\"\" 把你的代码进行封装，默认是不执行，使用时调用即可。=\"\" 优势：=\"\" 方便维护代码，一个函数多个地方使用=\"\" 使用者，不需要关心函数的实现过程，只需要考虑结果=\"\" 声明方式=\"\" function=\"\" 标识符=\"\" ()=\"\" {代码块}=\"\" {}=\"\" 也是一种数据类型，它属于对象，但是是一种特殊的对象。=\"\" 【注意】：用typeof=\"\" 检测数据类型，返回的是'function';=\"\" 如何获取函数传入的所有实参？=\"\" 通过argument获取，=\"\" 是一个集合，类数组。=\"\" 自执行函数=\"\" (function(){}())=\"\" 匿名函数：=\"\" function()=\"\" {},=\"\" 没有标识符=\"\" 形参，=\"\" 实参=\"\" 形参：=\"\" 函数定义时，括号内写入的变量=\"\" 实参：=\"\" ，函数执行时括号内传入的值=\"\" 如果定义了形参，没有传入实参的话，形参默认是undefined=\"\" 传入的实参和形参是一一对应关系=\"\" 浏览器在执行函数时，默认会在第一行把形参声明成变量=\"\" return=\"\" 关键字=\"\" 作用：=\"\" 终止函数执行。=\"\" 返回一个函数的值=\"\" 如果没有返回值，默认返回undefined;=\"\" 事件：用户与浏览器交互的瞬间=\"\" 事件处理程序：用户触发事件，处理事件的函数=\"\" 变量提升：=\"\" 在作用域代码执行前，当前作用域的代码会提前进行变量提升，=\"\" 就是把var声明的变量默认放到当前作用域的最前面，只声明不赋值=\"\" 函数（function=\"\" {}）也会进行提升，声明且赋值=\"\" 作用域：=\"\" js代码可以执行的地方。=\"\" 全局作用域：一个html里面所有script标签=\"\" 局部作用域：=\"\" 在es5中，函数作用域。=\"\" 1.局部作用域的变量是不可以被外界访问=\"\" 2.全局变量可以被局部使用=\"\" fn()=\"\" 函数作用域=\"\" 作用域链：=\"\" 当局部作用域使用一个变量时，如果存在变量（var=\"\" 一个变量），直接使用，=\"\" 如果不存在，向上一个作用域进行查找，直到找到全局作用域，如果还没有，浏览器报错（证明没有生命果该变量）=\"\" 数组：有序的集合。有索引（数字表示），=\"\" 值(任意一种数据类型)；=\"\" 1.数组的声明=\"\" 1.字面量方式=\"\" arr=\"[1,\" 2,=\"\" 3,=\"\" 4,=\"\" 5];=\"\" 2.构造函数模式=\"\" js中是没有类的概念，但是可以通过构造函数来实现这种方式=\"\" arr4=\"new\" array(1,2,3,4,5);=\"\" 当传入一个参数，且参数为数字的时候，参数代表的是生成数组的长度，里面没有元素。=\"\" 数组的最大长度为=\"\" 2**32=\"\" 2.数组遍历=\"\" 通过索引获取数组中的元素=\"\" 'haha',=\"\" '日子'];=\"\" for(var=\"\" i=\"0;\" <=\"\" arr.length;=\"\" i++)=\"\" 打印数组中的每一个元素=\"\" console.log(arr[i]);=\"\" 3.修改数组的值=\"\" 修改数组的值，如果不存在，则设置一个新值。=\"\" 如果长度不够，自动补全。=\"\" 稀疏数组：数组中如果存在empty=\"\" 密集数组：数组的元素个数跟长度一样=\"\" pop删除数组中最后一个元素，=\"\" 返回删除的元素，=\"\" 会改变原有数组=\"\" push：=\"\" 添加元素，在数组的最后面,=\"\" 返回数组的长度，=\"\" shift：=\"\" 删除数组中第一个元素，=\"\" 返回第一个删除的元素，会改变原有数组=\"\" unshift:=\"\" 在数组前面添加元素，返回数组长度，会改变原有数组。=\"\" splice:=\"\" 至少有两个参数，第一参数：开始位置，影响的个数，=\"\" 第三个至更多：需要替换的值=\"\" 然后返回被删除的项目=\"\" 截取数组=\"\" slice:=\"\" 截取数组，一个参数：=\"\" 开始位置，第二个：(选填)结束位置，=\"\" 如果第二个参数不写，=\"\" 默认截取到最后一个=\"\" 不会改变原有数组，=\"\" 返回值就是截取的数组。=\"\" 1.基本数据类型=\"\" string,=\"\" number,=\"\" null,=\"\" undefined,=\"\" boolean=\"\" 【注意】：值是不可以进行改变=\"\" 2.引用数据类型=\"\" 对象：array，=\"\" date,=\"\" function,=\"\" regexp......=\"\" 基本数据类型，改变值相当于重新赋值。=\"\" 什么是引用数据类型?=\"\" 当声明一个对象(引用数据类型)时，=\"\" 在堆内存中开辟一个地方，=\"\" 用来存储值，并把这个地址返回给变量。=\"\" 对象：无序的集合=\"\" 对象左边是key值，=\"\" 也称之为索引=\"\" 右边的：=\"\" 代表值，任意数据类型=\"\" concat(),=\"\" join(),=\"\" reverse(),=\"\" sort(),=\"\" map(),=\"\" filter(),=\"\" foreach()=\"\" concat():=\"\" 合并数组，返回合并的结果,=\"\" 不改变原有数组=\"\" join()：把数组拼接成字符串，括号内传入拼接符，不改变原有数组=\"\" foreach()不会改变数组本身=\"\" reverse():颠倒数组元素。会改变原有数组。=\"\" es5新增方法=\"\" 高阶函数=\"\" ,函数的参数还是函数=\"\" map()循环数组，括号内传入一个函数，函数的形参代表的是每一个数组元素，=\"\" 传入的函数设置返回值，当前元素变为返回值=\"\" 【注意】：有几个元素循环几次，empty不会触发循环=\"\" filter()过滤数组，返回满足条件的元素=\"\" arr.foreach(function(item,=\"\" index,=\"\" arr)=\"\" item=\"\" 数组的元素，=\"\" index代表元素的索引，=\"\" arr循环的数组=\"\" console.log(item,=\"\" arr);=\"\" })=\"\" 别人定义的函数，=\"\" 传入一个函数，设置三个参数，可以求和=\"\" fn(a)=\"\" a(10,20,30)=\"\" a=\"function(b,\" c,=\"\" d)=\"\" b=\"\" c=\"\" d;=\"\" fn(a);=\"\" sort()比较，根据字符串进行比较（字符串比大小，是根据ascii码=\"\" 表进行比较）；=\"\" sort()高级用法：传入一个函数，函数有两个参数：a,=\"\" b。=\"\" 如果函数返回=\"\" b,返回从小到大排序的数组。=\"\" 如果函数return=\"\" ,返回从大到小的数组=\"\" touppercase()把一个字符串全部变为大写：=\"\" tolowercase=\"\" 小写=\"\" charat():=\"\" 查找对应下标的字符=\"\" charcodeat()=\"\" 返回对应字符的ascii编码=\"\" concat()=\"\" 拼接字符串=\"\" slice()截取字符串=\"\" 开始到结束=\"\" substring(),=\"\" 截取字符串：=\"\" 默认把最小的参数当做开始位置，大的数字结束位置=\"\" substr()=\"\" 起始位置，截取个数=\"\" indexof=\"\" 查找元素，返回下标=\"\" replace()=\"\" 替换字符串=\"\" split():=\"\" 括号内是分割符号，返回数组=\"\" trim():=\"\" 去除前后空格=\"\" instanceof=\"\" 判断类型=\"\" 称为基本包装类型=\"\" 当基本包装类型使用方法时，内存中会默认创建一个对应的对象,使用调用的方法，把值返回，最后销毁。=\"\" 基本数据类型不可以添加属性，=\"\" 添加后会被销毁=\"\" 什么是深拷贝，=\"\" 什么是浅拷贝？=\"\" 深拷贝：引用数据类型的值复制给另外一个变量，其中一个值改变，不会影响另外一个=\"\" 浅拷贝：引用数据类型把地址给了另外一个变量，其中一个改变，另外一个也会改变。=\"\" 返回当前电脑时间，为字符串=\"\" date=\"Date();\" 不传参数,=\"\" 返回电脑电脑时间的日期对象=\"\" date();=\"\" 传一个参数：=\"\" 1.为字符串，=\"\" 必须是日期字符串，返回当前日期对象=\"\" 如果数字，代表毫秒，返回格林尼治时间+这个毫秒数的日期=\"\" date.gettime()；当前日期对象到格林尼治时间的毫秒数：=\"\" date.parse()=\"\" 默认传日期字符串，=\"\" 返回当前日期字符串到格林尼治时间的毫秒数=\"\" date.getfullyear(),=\"\" date.getmonth(),=\"\" date.getdate()，=\"\" date.gethours(),=\"\" date.getminutes(),=\"\" date.getseconds()，=\"\" 日期对象转为年月日=\"\" console.log(date.tolocaledatestring());=\"\" 日期对象转为时分秒=\"\" console.log(date.tolocaletimestring());=\"\" console.log(date.tolocalestring());=\"\" 定时器：=\"\" 一定时间去只执行函数=\"\" （多次）setinterval=\"\" 延时器:=\"\" 预约函数多少毫秒以后执行（一次）settimeout=\"\" clearinterval();=\"\" cleartimeout();=\"\" window=\"\" 是js运行在浏览器环境中，全局对象为window=\"\" navigator=\"\" :=\"\" useragent:查看浏览器基本信息=\"\" screen:=\"\" 获取屏幕尺寸=\"\" location:=\"\" 浏览器地址，=\"\" 导航栏=\"\" host:=\"\" ip地址=\"\" 端口号=\"\" developer.mozilla.org:4097=\"\" hostname:=\"\" developer.mozilla.org=\"\" hash:=\"\" #+后面的内容=\"\" href：=\"\" 整个地址=\"\" pathname：=\"\" 文件地址：=\"\" host之后，？之前=\"\" search：=\"\" ?后面的内容=\"\" port：=\"\" protocol：=\"\" 传输协议=\"\" （http:）=\"\" assign()=\"\" 跳转链接=\"=\"> location.href = 'http://www.baidu.com';\n            // reload() // 重新加载\n            // replace() // 跳转链接 地址不会保存在历史记录中\n            // history ；历史记录\n            // length: 打开的tab页记录的历史条数\n            // go():  跳转页面 正数前进， 负数后退\n            // back()： 后退\n            // forward()：前进\n            // open:打开新窗体\n            //  地址、打开方式：默认是_blank\n    \n     document.getElementById('ulbox');\n    document.querySelector('#ulbox');\n    document.getElementsByClassName('item');\n    document.querySelectorAll('.item');\n    document.getElementsByTagName('li');\n    getAttribute 获取属性 \n    setAttribute 设置属性 \n     \n    \n     // 节点类型      nodeType     nodeValue    nodeName\n            // ->元素节点      1             null       标签名称\n            // ->文本节点      3             文本内容    #text\n            // ->注释节点      8             注释内容    #comment\n            // ->根节点        9              null      #document\n    \n    \n    1 、增 ---------createElement\n    var oDiv = document.createElement('div');\n    //appendChild();// 添加到父节点的最后面\n     // insertBefore： 添加到某个元素的前面，第一个：要加入的元素， 第二个：已知节点\n          $ul.insertBefore($comment, $liClass);\n    // replaceChild： 替换节点： 第一个：替换的元素， 第二个：被替换的元素\n                $ul.replaceChild($text, $liOne);\n    // 克隆节点:cloneNode(),有一个布尔类型的参数: true: 完全克隆 false: 表面克隆，只克隆本身，不克隆子元素\n    \n    2 、删 ---------removeChild, remove()\n    语法 :fatherObj.removeChild(childrenObj)\n    参数解释：\n    a 、 fatherObj: 要删除子元素的元素对象\n    b 、 childrenObj: 要被删除的子元素对象\n    \n    3 、改 ---------\n    input.value = 'xxx';\n    btn.id = 'xx';\n    oDiv.style.color='xx';\n    \n    4 、查 --------- 六种\n    document.getElementById(''); 常用\n    document.getElementsByClassName('');(ie9+) 常用\n    document.getElementsByTagName(''); 常用\n    document.getElementsByName(''); 不常用\n    document.querySelector( 选择器 )(IE8+)(IE8+)\n    根据选择器返回匹配到的第一个元素\n    document.querySelectorAll( 选择器 );(IE8+) 常用\n    根据选择器返回匹配到的所有的元素\n    \n     // 创建元素节点， 括号内写标签名称\n            // 创建文本节点，括号内写文本内容\n            var $text = document.createTextNode('你好世界！！！');\n            // 创建注释文本，括号内写注释文本\n            var $comment = document.createComment('<li></li>');\n            // 创建文档碎片, 没有参数\n            var $frag = document.createDocumentFragment();\n            // 文档碎片相当于一个空盒子， 可以把创建的节点先加入到文档碎片中，然后在一次性添加到文档中\n            // 目的：减少文档的重拍重绘，提高性能。\n    \n     // clientLeft, clientTop 边框边距\n    // clientWidth，clientHeight 可视区域的尺寸\n    // offsetWidth, offsetHeight 实际尺寸 (可视尺寸+ 边框)\n    \n     // 获取子元素\n            childNodes //获取子节点\n            children  // 获取子元素\n            firstChild// 获取第一个子节点\n            firstElementChild// 获取第一个子元素子节点\n            console.log($ul.lastChild);  //获取最有一子节点\n            console.log($ul.lastElementChild);\n    \n            // 获取父元素\n            console.log(($ul.lastElementChild.parentNode.parentNode)); //获取父级元素\n            console.log(($ul.lastElementChild.parentElement));\n    \n            // 查找兄弟元素\n    \n            console.log($ul.lastElementChild.previousElementSibling);// 上一个元素节点\n            console.log($ul.previousSibling); // 上一个节点\n            console.log($ul.previousElementSibling); \n            console.log($ul.lastElementChild.nextSibling);\n            console.log($ul.nextElementSibling);\n    \n    \n    \n      // 事件\n            //  -> 用户和浏览器交互的瞬间\n            // 事件处理程序\n            //  -> 处理事件的函数\n            //  -> this指向绑定的元素\n            // 函数this指向\n            //  -> 1. 全局作用域this指向window\n            //  -> 2. 函数作用域中.this指向只与函数调用方式有关 谁调用指向谁\n            // 鼠标事件\n            //  -> 1. mousedown: 鼠标按下事件\n            //  -> 2. mouseup: 鼠标抬起\n            //  -> 3. mousemove: 鼠标移动\n            //  -> 4. mouseenter: 鼠标进入\n            //  -> 5. mouseleave: 鼠标移出\n            //  -> 6. mouseover: 鼠标进入: 给子元素也添加事件处理程序\n            //  -> 7. mouseout: 鼠标移出\n            // 鼠标位置获取\n            //  -> 1. clientX,Y: 相对于浏览器的位置\n            //  -> 2. pageX,Y: 相对于整个文档\n            //  -> 3. offsetX,Y: 相对于元素的位置 \n    元素位置的获取\n     offsetWidth: 获取元素宽度+边框\n     clientWidth: 获取元素可视宽度\n     clientLeft: 获取元素左边框的宽度\n    offsetTop: 获取元素距离父级顶部的距离（父级：当前元素向上级元素寻找，如果有定位就是父级，如果没有知道找到body，body默认为父级）\n    \n            //  -> 微软：冒泡流， 从最具体的元素传递到最不具体的元素（document）\n            //  -> 网景：捕获流， 从最不具体的元素传递到最具体的元素\n            // 事件流： 描述事件传递顺序（传递过程）,默认是冒泡流;\n    \n            // dom事件流： 描述dom2级事件传递过程\n            // 三个阶段：捕获阶段、处于自身阶段、冒泡阶段\n            // 规定在dom2级中捕获阶段不可以触发事件， 但是浏览器都支持在捕获阶段触发\n    \n            // dom2级事件\n            // 添加事件（事件监听）\n            // addEventListener():三个参数： 事件类型， 事件处理程序，bool是否捕获阶段触发\n    \n    // dom0级： 一个元素相同事件只能添加一个事件处理程序\n            // this指向事件绑定的元素\n            $box.onclick = function() {\n                console.log('我是谁？')\n            }\n    \n            // dom2级： 一个元素相同事件可以添加多个事件处理程序\n            //  this指向事件绑定的元素\n            $box.addEventListener('click', function () {\n                console.log('我是div');\n            }, true);\n    \n          // 移出事件：\n                // DOM0\n                $box.onclick = null;\n                // DOM2\n                // removeEventListener():传入的参数跟添加事件监听时传入的参数一一对应， 且恒等于才可以取消\n          $box.removeEventListener('click', fn, false)\n    \n    // ie8之前\n            var $btn = document.getElementById('btn');\n            // 添加事件：attachEvent() : on + 事件类型， 事件处理程序\n            // this指向全局的window\n            $btn.attachEvent('onclick', function(){\n                console.log('我是按钮')\n            })\n            $btn.attachEvent('onclick',fn)\n            function fn(){\n                console.log('我是按钮2222');\n            }\n            // 移除事件\n            $btn.detachEvent('onclick', fn)\n    \n    \n    \n    // 获取非行内样式\n            function getStyle(ele, attr) {\n                if(window.getComputedStyle) {\n                    return window.getComputedStyle(ele, null)[attr];\n                }\n                // 兼容ie 的写法\n                return ele.currentStyle[attr];\n            }\n    \n     // 阻止冒泡\n                 if(ev.stopPropagation) {\n                    ev.stopPropagation();\n                } else {\n                    // 兼容ie\n                    ev.cancelBubble = true;\n                }\n    \n    // 右键事件 document.oncontextmenu\n    //键盘按下\t $inp.onkeydown  键盘抬起$inp.onkeyup  //     // 不区分大小写可以组合键 \n     键盘按压$inp.onkeypress  // 1.可以区分大小写 // 2.不可以检测组合键\n     // 返回对应按键的ASCII编码    var keyCode = ev.keyCode || ev.which;\n    // 组合键  if(ev.ctrlKey) {\n            //         if(keyCode == 13) {\n            //             console.log('按下了 ctrl + enter');\n            //         } else if (keyCode == 80) {\n            //             console.log('按下了 ctrl + p');\n            //             ev.preventDefault();\n            //         }\n    \n    //清除浏览器默认行为 1， ev.preventDefault();\n          2，if(ev.preventDefault) {\n                        ev.preventDefault()\n                      } else {\n                        ev.returnValue = false;\n                        }\n        3,return false (不建议)\n            // focus: 文本框获取焦点时触发事件\n            // blur: 文本框失去焦点时触发事件\n            // change: 文本框失去焦点，较上一次内容，如果发生改变触发事件\n            // input: 文本框内容改变，立即触发\n    \n     // 事件委托：本身自己完成的事件交给父级来代替完成\n    // 获取目标元素：event.target || event.srcElement\n      // 优点：相同事件只需创建一次即可，减少资源浪费，提高性能\n           // 【注意:】不是所有的事件都可以利用事件委托\n    \n     // 正则表达式： 字符串按照某种规则进行匹配\n            // 字面量\n            var reg = /123/;\n            // 构造函数\n            var reg = new RegExp('123');\n    \n    // 正则表达式组成部分\n    \n            // 修饰符\n            // g 全局匹配\n            // i 字母不区分大小写\n            // m 区分多行\n    \n    //  元字符\n            . 匹配除了（\\n）换行符以外的任意字符\n             \\  转义符\n             \\d 0-9的数字\n             \\D 非数字\n             \\w 字母， 数字, _\n             \\s 匹配空字符\n             \\b 匹配边缘\n    \n    ^ 开始符号\n            // $ 结束符号\n    \n    量词元字符\n            // * 0次或者多次\n            // + 至少一次 {1,}\n            // ? 0次或者1次\n            // {m} m次\n            // {m, n} m次到n次\n            // {m,} 至少m次 \n            // [abc] a、b、c的其中一个\n                // -> [a-z]\n                // -> [a-zA-Z0-9]\n            // a|b  a或者b选一个\n    \n            // () 分组\n    \n    test() 检测字符串是否满足正则表达式规则，如果满足返回true，不满足返回false\n     exec()   字符串捕获，返回满足正则表达式的字符\n            // 捕获不到，返回结果null\n    // 贪婪性： 把一次满足条件的结果一下返回\n    // 懒惰性： 找到一个满足的条件，后面不在继续经行寻找\n    lastindex: 开始的位置， 每次查询完毕后， 记录这一次最后的位置。\n            // 当捕获的内容为null时， lastindex会重置。\n    \n    \n      //  字符串中正则的使用\n     replace() 替换字符\n    search  查询满足条件的字符串\n     match  捕获满足条件的字符串\n    \n    // call, apply 改变函数内部this指向\n            // call和apply： 第一个参数： this指向的对象\n            // call第二个参数及跟多，都是传入函数的实参\n            // apply 第二个参数： 是实参的集合\n    \n     // let 声明一个变量， const声明一个常量\n            // let跟const： const一经声明，就不可以重新赋值，但是let声明的可以\n            // let、const 和var的区别：\n                // 1. 变量名称不可以重复\n                // 2. 不存在变量提升，使用变量不能再声明前使用(暂时性死区)\n                // 3. 会生成块级作用域\n    \n    解构赋值\n    var arr = [1,2,3,4,5];\n            var [a,b,c,d] = arr;\n            console.log(a, b, c, d);//1,2,3,4\n    ...\n     var arr1 = [1,23,3,45,5];\n            var arr2 = [4,5,6,7,8];\n            arr1 = [...arr1, ...arr2];\n    \n    'use strict'\n            // 严格模式优点\n                // 1.减少js代码中不合理的地方，保证js代码的运行安全\n                // 2.提高编译器的效率\n                // 3. 为未来js版本做铺垫\n    \n            // 开启严格模式： 在作用域最上面写上 'use strict'\n            // 1.不能使用未声明的变量\n            // 2.再严格模式下，函数如果没有调用者，this指向null或者undefined\n            // 3.在严格模式下，arguments元素改变， 对应的形参不会改变。\n            // 4. 在严格模式下, arguments不可以重新赋值\n            // 5. 严格模式下，不可以执行使用八进制\n            // 6. 严格模式下不可以使用with语句\n    \n    //字符串模板 `${}`\n     // Set: 不允许元素重复(跟数组差不多，只不过元素不能重复)\n    \n    // 查询是否存在某个元素\n            console.log(a.has(100));\n            // 清空所有元素\n            // a.clear();\n            console.log(a);\n            // size,length表示元素个数\n    \n            // Map 用法类似于对象，结构类似于二维数组\n            // 和对象的区别：Map的属性可以是任意值\n            var map = new Map([[{}, 'xiaoaln'], [function(){}, 18], ['color', 'red']]);\n            \n            // 设置值：key， value\n    \n     // 数组去重\n            var arr = [1,2,3,4,1,2,2,12,3,1,23,1,23,1];\n            var set = new Set(arr);\n            arr = [...set];\n    \n    // 循环 for of 循环，循环元素，item代表的是元素\n            // 不可以循环object;\n     // for in循环对象的可枚举属性\n    // Symbol 第七种数据类型，返回一个独一无儿的值\n            // Symbol属于基本数据类型\n    \n      // 函数设置默认值\n            // function fn(x) {\n            //     x = x || 9;\n            // }\n            function fn(x = 9) {\n                console.log(x);\n            }\n    \n    // 箭头函数\n            var getName = (x) => {\n                console.log('111')\n            }\n            fn()\n    // 只有一个形参，函数只有一句代码，箭头函数才可以简写\n     // 箭头函数中的this指向上下文\n            // 上下文:函数声明时，所在的作用域\n    \n    //  var i=(function(){\n    //      return{\n    //          init:function(){\n    //              this.event();\n    //          },\n    //          event:function(){\n    //              var _this=this;\n    //          }\n    //      }\n    //  }())\n    //  init();\n</=（关系运算符）></,></pre>","categories":[],"tags":[{"name":"点击更多笔记","path":"api/tags/点击更多笔记.json"}]}