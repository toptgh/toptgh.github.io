{"title":"nodejs笔记","slug":"node","date":"2018-04-27T10:58:00.000Z","updated":"2018-12-06T06:28:27.567Z","comments":true,"excerpt":"","content":"<pre>\nJS代码不要超500行\n一般最大为200-300\n一个函数为当前屏幕长度\n要语义化\n注释写在函数前面\n全局变量要注释做什么的\n\n\n一个JS文件就是一个模块，相互不能访问\n如b.js要访问a.js\n则a.js需提供一个输出接口：module.exports={输入内容} (建议输出为对象)\nb.js需要引入接收：var aModule = require('./a.js');  console.log(aModule);\na.js没有提供输出接口Module时，b.js又打印了aModule，则输出为{}空对象\n输出和引入被称之为commonJS规范\n模块化开发是node.js独有的\n\n模块化：\n相对路径路径：仅在require方法使用 其他路径照常\n代表当前文件夹：./a.js\t(文件后缀可省略./a，默认先找文件夹，然后.js.json等)(index.html可以省略)\n绝对路径本地或者服务器的根目录：/a.js\n依赖路径：直接写文件名 a.js\t（依赖路径省略和gulp一样）\nnode内置模块：fs\nrequire引入需要注意：require第一次代码执行，之后不执行了，之后的require的结果，取第一次的缓存。\n\nfs模块：\nconst fs = require('fs');\n\n异步读文件：fs.readFile('hello.txt',function(error,data){\n\tconsole.log(data.toString());或者（data+''）//不转为字符串data为二进制 cmd中为了显示简洁转为16进制\n})\n同步：let result=fs.readFileSync('hello.txt');\n\n写文件：（会覆盖以前的内容）\n fs.writeFile('helloworld.txt', 'hello world', (error)=>{\n     console.log(error);\n });\nfs.writeFileSync('helloworld.txt', 'hello world');\n\n追加文件内容（不会覆盖）\nfs.appendFile('helloworld.txt', 'hello world', (error)=>{\n     console.log(error);\n });\nfs.appendFileSync('helloworld.txt', 'hello world');\n\n// 删除文件\n// fs.unlink('helloworld.txt');\n\n// 重命名文件\n// fs.rename('helloworld.txt', 'hello.txt');\n\n\n// 读文件状态\n// let result2 = fs.statSync('C:/Users/qf/Desktop/a.rar');\n// console.log(result2);\n// result2.mode =33206是文件  \n// result2.mode =16822是文件夹  \n\n// console.log(result2.isDirectory());//判断是否为文件夹\n// console.log(result2.isFile());//判断是否为文件\n\n\nurl模块：\nconst url = require('url');\n\n// url对url字符串进行解析\nlet path='www.baidu.com'\nlet result = url.parse(path, true);\nconsole.log(result);//URL对象\n// 参数1：需要解析的路径，\n// 参数2：是否解析请求参数为对象(可选)\n\n\n//url对象组装为一个url可请求的字符串\n// let result2 = url.format(pathObj);\n// console.log(result2);\n\n\nquerystring模块:\nconst qs= require('querystring');\n解析:\n// 对请求参数进行解析\nconst queryStr = 'username=zhangsan&password=123456&age=6&age=8';\nlet result1 = qs.parse(queryStr);\nconsole.log(result1);\n\n对对象转为请求参数的字符串\n// let result2 = qs.stringify(queryObj);\n\n querystring可以对特殊字符进行编解码\n编码：let result3 = qs.escape('上海');\n解码：let result4 = qs.unescape('%E4%B8%89%E9%98%B6%E6%AE%B5'）\n\n\nconst http = require('http');  //http请求默认端口是80\nconst https = require('https');  //https请求默认端口是443\n\n\n// 判断字符串是否有指定的子字符串为前缀\nstr.startsWith('www');\n// 判断字符串是否有指定的子字符串为后缀\nstr.endsWith('com');\n// 判断字符串是否有指定的子字符串\nstr.includes('baidu');\n\n/*\n跨域解决方式：\n    1.jsonp\n    2.后台允许跨域，注意安全问题。允许指定域名跨域\n    3.正向代理\n\n    项目开发的环境（服务器）：\n    开发环境 SAT\n    测试环境 UAT\n    生产环境/线上环境 PRO\n\n*/\n\n正向代理: 客户端需要对目标服务器发送请求,会存在跨域的问题，客户端向代理服务器发送请求，不会有跨域的问题。解决跨域：客户端向代理服务器，由代理服务器转发请求给目标服务器，代理服务器得到结果告诉客户端。\n代理的是客户端\nhttp-proxy-middleware 正向代理中间件\n反向代理？代理的是服务器\n\n我们常说的代理也就是只正向代理，正向代理的过程，它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求，某些科学上网工具扮演的就是典型的正向代理角色。用浏览器访问 http://www.google.com 时，被残忍的block，于是你可以在国外搭建一台代理服务器，让代理帮我去请求google.com，代理把请求返回的相应结构再返回给我。\n\n反向代理：隐藏了真实的服务端，当我们请求 www.baidu.com 的时候，就像拨打10086一样，背后可能有成千上万台服务器为我们服务，但具体是哪一台，你不知道，也不需要知道，你只需要知道反向代理服务器是谁就好了，www.baidu.com 就是我们的反向代理服务器，反向代理服务器会帮我们把请求转发到真实的服务器那里去。Nginx就是性能非常好的反向代理服务器，用来做负载均衡。\n两者的区别在于代理的对象不一样：正向代理:代理的对象是客户端，反向代理:代理的对象是服务端。\n\n使用node实现正向代理\n\nws  即时聊天功能\n\n\n使用插件实现服务器功能：\n//安装express插件流程：新建文件夹，npm init, cnpm i express -S和cnpm i body-parser -S\n\n//使用流程：require引入插件 express()创建服务器 listen启动服务器\n//get/post处理客户端请求和处理参数（get接收参数用query，post接收参数需要插件body-parser，直接获取body为undefined）\n//end()结束响应 \n\n//处理/get/post请求和参数具体流程：\n//接收客户端默认根目录请求，响应回去html页面，请求结束。JS发送ajax请求带参数，获取请求参数，响应回去成功，结束。\n\nsend（）方法包含写入和end()结束\n\n插件express的use()方法：参数一是URL，参数二是处理函数\nuse('/',(req,res,next)=>{}) //req客户端传入的参数 res响应客户端 next是一个函数，指向下一个操作函数。如果调用了next()下一个函数就会执行\nuse过滤请求路径的规则：\n请求路径只要以参数1为开头的路径就可以匹配。参数1匹配按路径一节为单位，\n参数1省略，或'/', 或'*' 都是匹配所有的路径\n/*\n如果请求的路径是：/api/goods/detail\n那么可以拦截到请求的use方法，url是以下几种情况：\nserver.use();\nserver.use('*');\nserver.use('/');\nserver.use('/api');\nserver.use('/api/goods');\nserver.use('/api/goods/detail');\n*/\n中间件会对请求的url进行切割, 执行next后，url又是完整的。\n\n中间件：use方法使用中间件 参数一是URL，参数二是处理函数，叫做中间件\n（可以理解为在一个JS封装了一个函数,然后输出，另一个JS文件引进use方法参数二调用）\n使用中间件：1.以上是自己封装使用中间件的方法\n\t    2.下载第三方插件http-proxy-middleware，引进后直接放use参数二使用\n\n__dirname当前文件夹的绝对路径\n__filename当前文件的绝对路径\n\n读取一个路径下的所有文件夹和文件，并转为对象\nconst fs = require('fs');\nfunction readDirInfo(path){\n    let obj = {};\n   // 读文件夹的所有文件\n    let result = fs.readdirSync(path);\n    result.map((item, index)=>{\n        // console.log(item);\n        let fullpath = path + '/' + item;\n        \n        // 读取每一个文件或文件夹的信息\n        let stat = fs.statSync(fullpath);\n        if(stat.isDirectory()){\n            //是文件夹\n            obj[item] = readDirInfo(fullpath);\n\n        }else if(stat.isFile()){\n            // 是文件\n            console.log(fullpath);\n            obj[item] = true;\n        }\n    });\n\n    return obj;\n\n};\nlet res = readDirInfo('D:/三阶段/1808/day1023');\nconsole.log(res);\nfs.writeFile('data.json', JSON.stringify(res), ()=>{});\n\n使用路由处理请求：（路由）\n引入路由对象\nconst server = express(); 服务器\n// 1.处理静态资源文件的请求（css/js/images...）\n// 参数1：所有静态资源请求url的开头\n// 参数2：express提供的处理静态资源的中间件，需要接收参数为：静态资源存放的目录\nserver.use('/static', express.static('public'));\n\n// 2.处理ajax请求(路由)\nserver.use('/api', ajaxRouter);\n\n// 3.处理页面请求(路由)\nserver.use('/', htmlRouter);\n\n监听服务器\n\n输出server\n\n中间件模块：创建路由对象，路由get请求 输出路由对象\n\n前后端不分离：利用模板引擎在后端把数据渲染到HTML页面，然后把完整HTML页面发给客户端\n使用模板引擎ejs：\n下载ejs插件\nconst ejs = require('ejs');\n// 参数1：固定字段\n// 参数2：模板引擎的名字,模板文件的后缀\nserver.set('view engine', 'html');\n// 在response对象中，可以调用render方法渲染模板，或者最终的html代码\n// 模板默认存放在views文件夹中\n\n// 设置模板存放的目录\n// 参数1：固定字段\n// 参数2：路径\nserver.set('views', './www');\n\n// 设置html模板引擎(后缀原来为ejs,设置后为HTML,其实用的还是ejs的功能)\nserver.engine('html', ejs.__express);\n\n中间件处理数据到HTML页面 数据必须为对象\nejs语法:<%%>处理JSfor循环等\n<%=%>处理变量\n<%-include()%> 引进页面\n\nmongodb数据库使用\n执行命令：\n设置路径：mongod --dbpath=数据库数据的存放路径 --port=27017\n连接数据库：mongoose.connect('mongodb://localhost:27018', {useNewUrlParser: true}, (error)=>{}）\n1.在项目新建文件夹为db\n2.在mongodb安装目录cmd打开窗口 输入modgod --dbpath=db文件夹的路径 --port=27018(默认为27017)\n3.启动服务器。\n必须执行以上步骤才能开启成功 命令窗口不能关。\n数据库可视化按ctrl+R 刷新\n\n数据增删改查\n创建表格字段：const schema=new mongoose.Schema({})\n创建操作数据库表格模型：const student=mongoose.model('student',schema)\n\n// 新增数据\n    // let studentInfo = new Student({\n    //     name: '张三',\n    //     age: 10,\n    //     sex: '男'\n    // });\nstudentInfo.save((error, info)=>{})\n\n\n查询\n // 查询所有\nStudent.find((error, result)=>{})\n\n// 查询总数\nStudent.countDocuments((error, result)=>{}）\n\n// 按条件查找1：\nStudent.where({name: '张三'}).find((error, result)=>{})\nStudent.where({name: '张三'}).countDocuments((error, result)=>{})\n $gt  大于\n    $lt  小于\n    $gte 大于等于\n    $lte 小于等于\n    $ne 不等于\n    $regex  正则\n    $or  或\n//查找年满18周岁,低于60岁\n    Student.find({age: {$gte: 18, $lt: 60}}).then((result)=>{}）\n// 查找姓李的\n    let reg2 = new RegExp(/^李/);\n    Student.find({name: {$regex: reg2}}).then(result=>{}）\n// 排序 -1降序   1升序\n    Student.find().sort({age: -1}).then((result)=>{}）\n\n// skip(num)跳过前面多少条数据开始查询   (page-1)*count\n    // limit(num)需要多少条数据的长度        count\n    Student.find().skip(4).limit(2).then((result)=>{}）\n\n// 按照条件查找2:\nStudent.find({name: '张三'}, (error, result)=>{})\n\n // 查找一个\n// Student.findOne({name: '张三'})\n// Student.where({name: '张三'}).findOne((error, result)=>{})\n\n// 根据id查询\n// Student.findById('5bd28a2c23366a108071ad91', (error, result)=>{})\n\n\n// 修改，更新\n//修改第一个\n    // Student.updateOne({name: '王五'}, {age: 66})\n    // Student.findOneAndUpdate({name: '王五'}, {age: 66})\n    // Student.update({name: '王五'}, {age: 66}, (error, result)=>{})\n\n // 修改多个\n    // Student.updateMany({name: '张三'}, {sex: '女'}, (error, result)=>{})\n\n// 根据id修改\n    Student.findByIdAndUpdate('5bd28ad600838d100cea5fe6', {name: \"赵六\", sex: '男'}, (error, result)=>{})\n\n\n删除\n// 删除满足条件的所有数据\n    // Student.remove({name: '张三'}, (error, result)=>{})\n\n// 删除一个\n    // Student.findOneAndRemove({name: '王五'}, (error, result)=>{\n\n// 根据id删除\n    // Student.findByIdAndRemove('5bd28a2c23366a108071ad91', (error, result)=>{\n</%-include()%></%=%></%%></pre>\n\n\n\n\n\n\n\n\n","categories":[],"tags":[{"name":"点击更多笔记","path":"api/tags/点击更多笔记.json"}]}