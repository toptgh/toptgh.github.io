{"title":"JS汇总（持续更新）","slug":"JS汇总（持续更新）","date":"2018-10-02T10:18:00.000Z","updated":"2018-12-06T06:29:47.505Z","comments":true,"excerpt":"","content":"<p><strong>webstorage</strong></p>\n<h6 id=\"webstorage是本地存储，存储在客户端，包括localStorage和sessionStorage。\"><a href=\"#webstorage是本地存储，存储在客户端，包括localStorage和sessionStorage。\" class=\"headerlink\" title=\"webstorage是本地存储，存储在客户端，包括localStorage和sessionStorage。\"></a>webstorage是本地存储，存储在客户端，包括localStorage和sessionStorage。</h6><p><strong>localStorage</strong></p>\n<blockquote>\n<p>localStorage生命周期是永久，这意味着除非用户显示在浏览器提供的UI上清除localStorage信息，否则这些信息将永远存在。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。</p>\n</blockquote>\n<p><strong>sessionStorage</strong></p>\n<blockquote>\n<p>sessionStorage仅在当前会话下有效，关闭页面或浏览器后被清除。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信</p>\n</blockquote>\n<h6 id=\"localStorage和sessionStorage使用时使用相同的API\"><a href=\"#localStorage和sessionStorage使用时使用相同的API\" class=\"headerlink\" title=\"localStorage和sessionStorage使用时使用相同的API\"></a>localStorage和sessionStorage使用时使用相同的API</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">localStorage.setItem(&quot;key&quot;,&quot;value&quot;);//以“key”为名称存储一个值“value”</span><br><span class=\"line\"></span><br><span class=\"line\">localStorage.getItem(&quot;key&quot;);//获取名称为“key”的值</span><br><span class=\"line\"></span><br><span class=\"line\">localStorage.removeItem(&quot;key&quot;);//删除名称为“key”的信息。</span><br><span class=\"line\"></span><br><span class=\"line\">localStorage.clear();​//清空localStorage中所有信息</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>不同浏览器无法共享localStorage或sessionStorage中的信息。相同浏览器的不同页面间可以共享相同的 localStorage（页面属于相同域名和端口），但是不同页面或标签页间无法共享sessionStorage的信息。这里需要注意的是，页面及标 签页仅指顶级窗口，如果一个标签页包含多个iframe标签且他们属于同源页面，那么他们之间是可以共享sessionStorage的。</p>\n</blockquote>\n<p><strong>Cookie</strong></p>\n<blockquote>\n<p>生命期为只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。 存放数据大小为4K左右 。有个数限制（各浏览器不同），一般不能超过20个。与服务器端通信：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题</p>\n</blockquote>\n<h6 id=\"localStorage、sessionStorage、Cookie共同点：都是保存在浏览器端，且同源的。\"><a href=\"#localStorage、sessionStorage、Cookie共同点：都是保存在浏览器端，且同源的。\" class=\"headerlink\" title=\"localStorage、sessionStorage、Cookie共同点：都是保存在浏览器端，且同源的。\"></a>localStorage、sessionStorage、Cookie共同点：都是保存在浏览器端，且同源的。</h6><p><strong>如何用原生js给一个按钮绑定两个onclick事件</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var btn4 = document.getElementById(&quot;btn4&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">btn4.addEventListener(&quot;click&quot;,hello1);</span><br><span class=\"line\"></span><br><span class=\"line\">btn4.addEventListener(&quot;click&quot;,hello2);</span><br><span class=\"line\"></span><br><span class=\"line\"> </span><br><span class=\"line\"></span><br><span class=\"line\">function hello1()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> alert(&quot;hello 1&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function hello2()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> alert(&quot;hello 2&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>数组去重</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">方法一：</span><br><span class=\"line\">&lt;!--利用数组的indexOf下标属性来查询。--&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">function unique4(arr)&#123;</span><br><span class=\"line\"> var res = [];</span><br><span class=\"line\"> for(var i=0; i&lt;arr.length; i++)&#123;</span><br><span class=\"line\">  if(res.indexOf(arr[i]) == -1)&#123;</span><br><span class=\"line\">   res.push(arr[i]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> return res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>xml和json的区别，请用四个词语来形容</strong></p>\n<blockquote>\n<p>·  JSON相对于XML来讲，数据的体积小，传递的速度更快些</p>\n</blockquote>\n<blockquote>\n<p>·  JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互</p>\n</blockquote>\n<blockquote>\n<p>·  XML对数据描述性比较好；</p>\n</blockquote>\n<blockquote>\n<p>·  JSON的速度要远远快于XML</p>\n</blockquote>\n<p>ajax(异步javascript xml) 能够刷新局部网页数据而不是重新加载整个网页。</p>\n<p><strong>什么是AJAX</strong></p>\n<blockquote>\n<p>ajax(异步javascript xml) 能够刷新局部网页数据而不是重新加载整个网页</p>\n</blockquote>\n<p><strong>如何使用ajax?</strong></p>\n<blockquote>\n<p>第一步，创建xmlhttprequest对象</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var xmlhttp =new XMLHttpRequest（);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>XMLHttpRequest对象用来和服务器交换数据。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var xhttp;</span><br><span class=\"line\">if (window.XMLHttpRequest) &#123;</span><br><span class=\"line\">//现代主流浏览器</span><br><span class=\"line\">xhttp = new XMLHttpRequest();</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">// 针对浏览器，比如IE5或IE6</span><br><span class=\"line\">xhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>第二步，使用xmlhttprequest对象的open（）和send（）方法发送资源请求给服务器。</p>\n</blockquote>\n<blockquote>\n<p>第三步，使用xmlhttprequest对象的responseText或responseXML属性获得服务器的响应。</p>\n</blockquote>\n<blockquote>\n<p>第四步，onreadystatechange函数，当发送请求到服务器，我们想要服务器响应执行一些功能就需要使用onreadystatechange函数，每次xmlhttprequest对象的readyState发生改变都会触发onreadystatechange函数</p>\n</blockquote>\n<hr>\n<p><strong>undefined 和 null 区别</strong></p>\n<blockquote>\n<p>null： Null类型，代表“空值”，代表一个空对象指针，使用typeof运算得到 “object”，所以你可以认为它是一个特殊的对象值。<br>undefined： Undefined类型，当一个声明了一个变量未初始化时，得到的就是undefined。</p>\n</blockquote>\n<blockquote>\n<p>null是javascript的关键字，可以认为是对象类型，它是一个空对象指针，和其它语言一样都是代表“空值”，不过 undefined 却是javascript才有的。undefined是在ECMAScript第三版引入的，为了区分空指针对象和未初始化的变量，它是一个预定义的全局变量。没有返回值的函数返回为undefined，没有实参的形参也是undefined。</p>\n</blockquote>\n<blockquote>\n<p>javaScript权威指南： null 和 undefined 都表示“值的空缺”，你可以认为undefined是表示系统级的、出乎意料的或类似错误的值的空缺，而null是表示程序级的、正常的或在意料之中的值的空缺。</p>\n</blockquote>\n<hr>\n<p><strong>http 和 https 有何区别？如何灵活使用</strong></p>\n<blockquote>\n<p>http是HTTP协议运行在TCP之上。所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。</p>\n</blockquote>\n<blockquote>\n<p>https是HTTP运行在SSL/TLS之上，SSL/TLS运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。此外客户端可以验证服务器端的身份，如果配置了客户端验证，服务器方也可以验证客户端的身份</p>\n</blockquote>\n<hr>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">常见的HTTP状态码</span><br><span class=\"line\">2开头 （请求成功）表示成功处理了请求的状态代码。</span><br><span class=\"line\"></span><br><span class=\"line\">200   （成功）  服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 </span><br><span class=\"line\">201   （已创建）  请求成功并且服务器创建了新的资源。 </span><br><span class=\"line\">202   （已接受）  服务器已接受请求，但尚未处理。 </span><br><span class=\"line\">203   （非授权信息）  服务器已成功处理了请求，但返回的信息可能来自另一来源。 </span><br><span class=\"line\">204   （无内容）  服务器成功处理了请求，但没有返回任何内容。 </span><br><span class=\"line\">205   （重置内容） 服务器成功处理了请求，但没有返回任何内容。</span><br><span class=\"line\">206   （部分内容）  服务器成功处理了部分 GET 请求。</span><br><span class=\"line\"></span><br><span class=\"line\">3开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</span><br><span class=\"line\"></span><br><span class=\"line\">300   （多种选择）  针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 </span><br><span class=\"line\">301   （永久移动）  请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</span><br><span class=\"line\">302   （临时移动）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</span><br><span class=\"line\">303   （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</span><br><span class=\"line\">304   （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 </span><br><span class=\"line\">305   （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 </span><br><span class=\"line\">307   （临时重定向）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</span><br><span class=\"line\"></span><br><span class=\"line\">4开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。</span><br><span class=\"line\"></span><br><span class=\"line\">400   （错误请求） 服务器不理解请求的语法。 </span><br><span class=\"line\">401   （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 </span><br><span class=\"line\">403   （禁止） 服务器拒绝请求。</span><br><span class=\"line\">404   （未找到） 服务器找不到请求的网页。</span><br><span class=\"line\">405   （方法禁用） 禁用请求中指定的方法。 </span><br><span class=\"line\">406   （不接受） 无法使用请求的内容特性响应请求的网页。 </span><br><span class=\"line\">407   （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。</span><br><span class=\"line\">408   （请求超时）  服务器等候请求时发生超时。 </span><br><span class=\"line\">409   （冲突）  服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 </span><br><span class=\"line\">410   （已删除）  如果请求的资源已永久删除，服务器就会返回此响应。 </span><br><span class=\"line\">411   （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。 </span><br><span class=\"line\">412   （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。 </span><br><span class=\"line\">413   （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 </span><br><span class=\"line\">414   （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。 </span><br><span class=\"line\">415   （不支持的媒体类型） 请求的格式不受请求页面的支持。 </span><br><span class=\"line\">416   （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。 </span><br><span class=\"line\">417   （未满足期望值） 服务器未满足&quot;期望&quot;请求标头字段的要求。</span><br><span class=\"line\"></span><br><span class=\"line\">5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</span><br><span class=\"line\"></span><br><span class=\"line\">500   （服务器内部错误）  服务器遇到错误，无法完成请求。 </span><br><span class=\"line\">501   （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 </span><br><span class=\"line\">502   （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 </span><br><span class=\"line\">503   （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 </span><br><span class=\"line\">504   （网关超时）  服务器作为网关或代理，但是没有及时从上游服务器收到请求。 </span><br><span class=\"line\">505   （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</span><br></pre></td></tr></table></figure>\n<p><strong>如何进行网站性能优化</strong></p>\n<blockquote>\n<ol>\n<li>从用户角度而言，优化能够让页面加载得更快、对用户的操作响应得更及时，能够给用户提供更为友好的体验。</li>\n<li>从服务商角度而言，优化能够减少页面请求数、或者减小请求所占带宽，能够节省可观的资源。\n　　</li>\n</ol>\n</blockquote>\n<h6 id=\"总之，恰当的优化不仅能够改善站点的用户体验并且能够节省相当的资源利用。\"><a href=\"#总之，恰当的优化不仅能够改善站点的用户体验并且能够节省相当的资源利用。\" class=\"headerlink\" title=\"总之，恰当的优化不仅能够改善站点的用户体验并且能够节省相当的资源利用。\"></a>总之，恰当的优化不仅能够改善站点的用户体验并且能够节省相当的资源利用。</h6><blockquote>\n<p>前端优化的途径有很多，按粒度大致可以分为两类</p>\n</blockquote>\n<blockquote>\n<p>第一类是页面级别的优化，例如HTTP请求数、脚本的无阻塞加载、内联脚本的位置优化等;</p>\n</blockquote>\n<blockquote>\n<p>第二类则是代码级别的优化，例如Javascript中的DOM操作优化、CSS选择符优化、图片优化以及HTML结构优化等等。另外，本着提高投入产出比的目的，后文提到的各种优化策略大致按照投入产出比从大到小的顺序排列。</p>\n</blockquote>\n<p>　　一、页面级优化</p>\n<ol>\n<li>JavaScript 压缩和模块打包</li>\n<li>按需加载资源</li>\n<li>在使用 DOM 操作库时用上 array-ids</li>\n<li>缓存</li>\n<li>启用 HTTP/2</li>\n<li>应用性能分析</li>\n<li>使用负载均衡方案</li>\n<li>为了更快的启动时间考虑一下同构</li>\n<li>使用索引加速数据库查询</li>\n<li>使用更快的转译方案</li>\n<li>避免或最小化 JavaScript 和 CSS 的使用而阻塞渲染</li>\n<li>用于未来的一个建议：使用 service workers + 流</li>\n<li>图片编码优化</li>\n</ol>\n<hr>\n<p><strong>react和vue有哪些不同</strong></p>\n<h6 id=\"相同点\"><a href=\"#相同点\" class=\"headerlink\" title=\"相同点\"></a>相同点</h6><p>· 都支持服务器端渲染</p>\n<p>· 都有Virtual DOM,组件化开发,通过props参数进行父子组件数据的传递,都实现webComponent规范</p>\n<p>· 数据驱动视图</p>\n<p>· 都有支持native的方案,React的React native,Vue的weex</p>\n<h6 id=\"不同点\"><a href=\"#不同点\" class=\"headerlink\" title=\"不同点\"></a>不同点</h6><p>· React严格上只针对MVC的view层,Vue则是MVVM模式</p>\n<p>· virtual DOM不一样,vue会跟踪每一个组件的依赖关系,不需要重新渲染整个组件树.而对于React而言,每当应用的状态被改变时,全部组件都会重新渲染,所以react中会需要shouldComponentUpdate这个生命周期函数方法来进行控制</p>\n<p>· 组件写法不一样, React推荐的做法是 JSX + inline style, 也就是把HTML和CSS全都写进JavaScript了,即’all in js’; Vue推荐的做法是webpack+vue-loader的单文件组件格式,即html,css,jd写在同一个文件;</p>\n<p>· 数据绑定: vue实现了数据的双向绑定,react数据流动是单向的</p>\n<p>· state对象在react应用中不可变的,需要使用setState方法更新状态;在vue中,state对象不是必须的,数据由data属性在vue对象中管理</p>\n<hr>\n<p><strong>什么是mvvm mvc是什么区别 原理</strong></p>\n<h6 id=\"MVC（Model-View-Controller）\"><a href=\"#MVC（Model-View-Controller）\" class=\"headerlink\" title=\"MVC（Model-View-Controller）\"></a>MVC（Model-View-Controller）</h6><p>MVC是比较直观的架构模式，用户操作-&gt;View（负责接收用户的输入操作）-&gt;Controller（业务逻辑处理）-&gt;Model（数据持久化）-&gt;View（将结果反馈给View）。</p>\n<p>MVC使用非常广泛，比如JavaEE中的SSH框架</p>\n<h6 id=\"MVVM（Model-View-ViewModel）\"><a href=\"#MVVM（Model-View-ViewModel）\" class=\"headerlink\" title=\"MVVM（Model-View-ViewModel）\"></a>MVVM（Model-View-ViewModel）</h6><p>如果说MVP是对MVC的进一步改进，那么MVVM则是思想的完全变革。它是将“数据模型数据双向绑定”的思想作为核心，因此在View和Model之间没有联系，通过ViewModel进行交互，而且Model和ViewModel之间的交互是双向的，因此视图的数据的变化会同时修改数据源，而数据源数据的变化也会立即反应view。</p>\n<hr>\n<p><strong>eval()的作用</strong></p>\n<h6 id=\"把字符串参数解析成JS代码并运行，并返回执行的结果-产生独立作用域\"><a href=\"#把字符串参数解析成JS代码并运行，并返回执行的结果-产生独立作用域\" class=\"headerlink\" title=\"把字符串参数解析成JS代码并运行，并返回执行的结果,产生独立作用域\"></a>把字符串参数解析成JS代码并运行，并返回执行的结果,产生独立作用域</h6><hr>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eval(&quot;2+3&quot;);//执行加运算，并返回运算值。</span><br></pre></td></tr></table></figure>\n<p><strong>JS哪些操作会造成内存泄露</strong></p>\n<h6 id=\"1）意外的全局变量引起的内存泄露\"><a href=\"#1）意外的全局变量引起的内存泄露\" class=\"headerlink\" title=\"1）意外的全局变量引起的内存泄露\"></a>1）意外的全局变量引起的内存泄露</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function leak()&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">  leak=&quot;xxx&quot;;//leak成为一个全局变量，不会被回收  </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"2）闭包引起的内存泄露\"><a href=\"#2）闭包引起的内存泄露\" class=\"headerlink\" title=\"2）闭包引起的内存泄露\"></a>2）闭包引起的内存泄露</h6><h6 id=\"3）没有清理的DOM元素引用\"><a href=\"#3）没有清理的DOM元素引用\" class=\"headerlink\" title=\"3）没有清理的DOM元素引用\"></a>3）没有清理的DOM元素引用</h6><h6 id=\"4）被遗忘的定时器或者回调\"><a href=\"#4）被遗忘的定时器或者回调\" class=\"headerlink\" title=\"4）被遗忘的定时器或者回调\"></a>4）被遗忘的定时器或者回调</h6><h6 id=\"5）子元素存在引起的内存泄露\"><a href=\"#5）子元素存在引起的内存泄露\" class=\"headerlink\" title=\"5）子元素存在引起的内存泄露\"></a>5）子元素存在引起的内存泄露</h6><hr>\n<p><strong>bootstrap响应式实现的原理</strong></p>\n<h6 id=\"百分比布局-媒体查询\"><a href=\"#百分比布局-媒体查询\" class=\"headerlink\" title=\"百分比布局+媒体查询\"></a>百分比布局+媒体查询</h6><p><strong>什么是闭包，如何使用它，为什么要使用它？</strong></p>\n<blockquote>\n<p>就是能够读取其他函数内部变量的函数。由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。</p>\n</blockquote>\n<blockquote>\n<p>它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中,可以避免全局变量的污染。</p>\n</blockquote>\n<blockquote>\n<p>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p>\n</blockquote>\n<blockquote>\n<p>闭包会在父函数外部，改变父函数内部变量的值。</p>\n</blockquote>\n<p><strong>JSONP的工作原理，以及它为什么不是真正的AJAX</strong></p>\n<blockquote>\n<p>JSONP (JSON with Padding)是一个简单高效的跨域方式，HTML中的script标签可以加载并执行其他域的javascript，于是我们可以通过script标记来动态加载其他域的资源。例如我要从域A的页面pageA加载域B的数据，那么在域B的页面pageB中我以JavaScript的形式声明pageA需要的数据，然后在 pageA中用script标签把pageB加载进来，那么pageB中的脚本就会得以执行。JSONP在此基础上加入了回调函数，pageB加载完之后会执行pageA中定义的函数，所需要的数据会以参数的形式传递给该函数。JSONP易于实现，但是也会存在一些安全隐患，如果第三方的脚本随意地执行，那么它就可以篡改页面内容，截获敏感数据。但是在受信任的双方传递数据，JSONP是非常合适的选择。</p>\n</blockquote>\n<h6 id=\"AJAX是不跨域的，而JSONP是一个是跨域的，还有就是二者接收参数形式不一样！\"><a href=\"#AJAX是不跨域的，而JSONP是一个是跨域的，还有就是二者接收参数形式不一样！\" class=\"headerlink\" title=\"AJAX是不跨域的，而JSONP是一个是跨域的，还有就是二者接收参数形式不一样！\"></a>AJAX是不跨域的，而JSONP是一个是跨域的，还有就是二者接收参数形式不一样！</h6><hr>\n<p><strong>JavaScript的同源策略</strong></p>\n<blockquote>\n<p>同源策略浏览器的保护机制，规定跨域之间的脚本是隔离的，一个域的脚本不能访问和操作另外一个域的绝大部分属性和方法。那么什么叫相同域，什么叫不同的域呢？当两个域具有相同的协议, 相同的端口，相同的host，那么我们就可以认为它们是相同的域。同源策略还应该对一些特殊情况做处理，比如限制file协议下脚本的访问权限。本地的HTML文件在浏览器中是通过file协议打开的，如果脚本能通过file协议访问到硬盘上其它任意文件，就会出现安全隐患，目前IE8还有这样的隐患。</p>\n</blockquote>\n<hr>\n<p><strong>垃圾回收机制方式及内存管理</strong></p>\n<h6 id=\"回收机制方式\"><a href=\"#回收机制方式\" class=\"headerlink\" title=\"回收机制方式\"></a>回收机制方式</h6><p>1、定义和用法：垃圾回收机制(GC:Garbage Collection),执行环境负责管理代码执行过程中使用的内存。</p>\n<p>2、原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function fn1() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    var obj = &#123;name: &apos;hanzichi&apos;, age: 10&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function fn2() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    var obj = &#123;name:&apos;hanzichi&apos;, age: 10&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">   return obj;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;var a = fn1();var b = fn2();</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>fn1中定义的obj为局部变量，而当用结束后，出了fn1的环境，那么该块内存会被js引擎中的垃圾回收器自动释放；在fn2被调用的过程中，返回的对象被全局变量b所指向，所以该块内存并不会被释放。</p>\n</blockquote>\n<h6 id=\"垃圾回收策略：标记清除-较为常用-和引用计数。\"><a href=\"#垃圾回收策略：标记清除-较为常用-和引用计数。\" class=\"headerlink\" title=\"垃圾回收策略：标记清除(较为常用)和引用计数。\"></a>垃圾回收策略：标记清除(较为常用)和引用计数。</h6><p>标记清除：</p>\n<blockquote>\n<p>定义和用法：当变量进入环境时，将变量标记”进入环境”，当变量离开环境时，标记为：”离开环境”。某一个时刻，垃圾回收器会过滤掉环境中的变量，以及被环境变量引用的变量，剩下的就是被视为准备回收的变量。</p>\n</blockquote>\n<blockquote>\n<p>到目前为止，IE、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。</p>\n</blockquote>\n<p>引用计数：</p>\n<blockquote>\n<p>定义和用法：引用计数是跟踪记录每个值被引用的次数。</p>\n</blockquote>\n<blockquote>\n<p>基本原理：就是变量的引用次数，被引用一次则加1，当这个引用计数为0时，被视为准备回收的对象。</p>\n</blockquote>\n<p><strong>浏览器是如何渲染页面的</strong></p>\n<p>1.解析HTML文件，创建DOM树。<br>自上而下，遇到任何样式（link、style）与脚本（script）都会阻塞（外部样式不阻塞后续外部脚本的加载）。</p>\n<p>2.解析CSS。优先级：浏览器默认设置&lt;用户设置&lt;外部样式&lt;内联样式&lt;HTML中的style样式；</p>\n<p>3.将CSS与DOM合并，构建渲染树（Render Tree）</p>\n<p>4.布局和绘制，重绘（repaint）和重排（reflow）</p>\n<p><strong>从输入url到显示页面，都经历了什么</strong></p>\n<p>1、首先，在浏览器地址栏中输入url</p>\n<p>2、浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第三步操作。</p>\n<p>3、在发送http请求前，需要域名解析(DNS解析)(DNS（域名系统，Domain Name System）是互联网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住IP地址。)，解析获取相应的IP地址。</p>\n<p>4、浏览器向服务器发起tcp连接，与浏览器建立tcp三次握手。（TCP即传输控制协议。TCP连接是互联网连接协议集的一种。）</p>\n<p>5、握手成功后，浏览器向服务器发送http请求，请求数据包。</p>\n<p>6、服务器处理收到的请求，将数据返回至浏览器</p>\n<p>7、浏览器收到HTTP响应</p>\n<p>8、读取页面内容，浏览器渲染，解析html源码</p>\n<p>9、生成Dom树、解析css样式、js交互</p>\n<p>10、客户端和服务器交互</p>\n<p>11、ajax查询</p>\n<hr>\n<p><strong>JavaScript中如何检测一个变量是一个String类型？</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typeof(obj) === &quot;string&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">typeof obj === &quot;string&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.constructor === String</span><br></pre></td></tr></table></figure>\n<p><strong>判断一个字符串中出现次数最多的字符，统计这个次数</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &apos;asdfssaaasasasasaa&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">var json = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">for (var i = 0; i &lt; str.length; i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    if(!json[str.charAt(i)])&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       json[str.charAt(i)] = 1;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       json[str.charAt(i)]++;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;var iMax = 0;var iIndex = &apos;&apos;;for(var i in json)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    if(json[i]&gt;iMax)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">         iMax = json[i];</span><br><span class=\"line\"></span><br><span class=\"line\">         iIndex = i;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;        console.log(&apos;出现次数最多的是:&apos;+iIndex+&apos;出现&apos;+iMax+&apos;次&apos;);</span><br></pre></td></tr></table></figure>\n<p><strong>XSS攻击</strong></p>\n<blockquote>\n<p>XSS是一种经常出现在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。<br>其实在web前端方面，可以简单的理解为一种javascript代码注入</p>\n</blockquote>\n<blockquote>\n<p>举个例子，我们有个社交网站，允许大家相互访问空间，如果你的用户名，起名称的时候，带上script标签呢？我们知道，浏览器遇到html中的script标签的时候，会解析并执行标签中的js脚本代码，那么如果你的用户名称里面含有script标签的话，就可以执行其中的代码了,<br>如果你将自己的用户名设定为这种执行脚本的方式，再让别人去访问你的连接的话，就可以达到在他人web环境中，执行自己脚本的效果了。我们还可以使用ajax，将其他用户在当前域名下的cookie获取并发送到自己的服务器上。这样就可以获取他人信息了</p>\n</blockquote>\n<p><strong>如何防范</strong></p>\n<blockquote>\n<p>最简单的办法防治办法，还是将前端输出数据都进行转义最为稳妥</p>\n</blockquote>\n<blockquote>\n<p>其本质是，浏览器遇到script标签的话，则会执行其中的脚本。但是如果我们将script标签的进行转义，则浏览器便不会认为其是一个标签，但是显示的时候，还是会按照正常的方式去显示</p>\n</blockquote>\n<p><strong>CSRF攻击</strong></p>\n<blockquote>\n<p>CSRF（Cross-site request forgery跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。<br>其实就是网站中的一些提交行为，被黑客利用，你在访问黑客的网站的时候，进行的操作，会被操作到其他网站上(如：你所使用的网络银行的网站)。</p>\n</blockquote>\n<p><strong>如何防御</strong></p>\n<blockquote>\n<p>最简单的办法就是加验证码，这样除了用户，黑客的网站是获取不到用户本次session的验证码的,但是这样也会降低用户的提交体验</p>\n</blockquote>\n<blockquote>\n<p>另一种方式，就是在用访问的页面中，都种下验证用的token，用户所有的提交都必须带上本次页面中生成的token，这种方式的本质和使用验证码没什么两样，但是这种方式，整个页面每一次的session，使用同一个token就行，很多post操作，开发者就可以自动带上当前页面的token。如果token校验不通过，则证明此次提交并非从本站发送来，则终止提交过程。如果token确实为本网站生成的话，则可以通过</p>\n</blockquote>\n<p><strong>网络劫持攻击</strong></p>\n<blockquote>\n<p>很多的时候，我们的网站不是直接就访问到我们的服务器上的，中间会经过很多层代理，如果在某一个环节，数据被中间代理层的劫持者所截获，他们就能获取到使用你网站的用户的密码等保密数据。比如，我们的用户经常会在各种饭馆里面，连一些奇奇怪怪的wifi，如果这个wifi是黑客所建立的热点wifi，那么黑客就可以结果该用户收发的所有数据</p>\n</blockquote>\n<p><strong>控制台注入代码</strong></p>\n<blockquote>\n<p>有的黑客会诱骗用户去往控制台里面粘贴东西（欺负小白用户不懂代码），比如可以在朋友圈贴个什么文章，说:”只要访问天猫，按下F12并且粘贴以下内容，则可以获得xx元礼品”之类的，那么有的用户真的会去操作，并且自己隐私被暴露了也不知道。</p>\n</blockquote>\n<p><img src=\"https://segmentfault.com/img/bVB9MV\" alt=\"image\"></p>\n<p><strong>钓鱼</strong></p>\n<blockquote>\n<p>打开之后发现一个QQ登录框，其实一看域名就知道不是QQ，不过做得非常像QQ登录，不明就里的用户们，就真的把用户名和密码输入了进去，结果没登录到QQ，用户名和密码却给人发过去了</p>\n</blockquote>\n<h6 id=\"如果给一个变量赋值一个对象，那么两者的值会是同一个引用，其中一方改变，另一方也会相应改变\"><a href=\"#如果给一个变量赋值一个对象，那么两者的值会是同一个引用，其中一方改变，另一方也会相应改变\" class=\"headerlink\" title=\"如果给一个变量赋值一个对象，那么两者的值会是同一个引用，其中一方改变，另一方也会相应改变\"></a>如果给一个变量赋值一个对象，那么两者的值会是同一个引用，其中一方改变，另一方也会相应改变</h6><p><strong>浅拷贝解决办法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//Object.assign解决</span><br><span class=\"line\">let a = &#123;</span><br><span class=\"line\">    age: 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let b = Object.assign(&#123;&#125;, a)</span><br><span class=\"line\">a.age = 2</span><br><span class=\"line\">console.log(b.age) // 1</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//运算符（…）来解决</span><br><span class=\"line\">let a = &#123;</span><br><span class=\"line\">    age: 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let b = &#123;...a&#125;</span><br><span class=\"line\">a.age = 2</span><br><span class=\"line\">console.log(b.age) // 1</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>浅拷贝只解决了第一层的问题，如果接下去的值中还有对象的话，那么就又回到刚开始的话题了，两者享有相同的引用。要解决这个问题，我们需要引入深拷贝</p>\n</blockquote>\n<p><strong>深拷贝解决办法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//JSON.parse(JSON.stringify(object)) 来解决</span><br><span class=\"line\">let a = &#123;</span><br><span class=\"line\">    age: 1,</span><br><span class=\"line\">    jobs: &#123;</span><br><span class=\"line\">        first: &apos;FE&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let b = JSON.parse(JSON.stringify(a))</span><br><span class=\"line\">a.jobs.first = &apos;native&apos;</span><br><span class=\"line\">console.log(b.jobs.first) // FE</span><br></pre></td></tr></table></figure>\n<h6 id=\"但是该方法也是有局限性的：\"><a href=\"#但是该方法也是有局限性的：\" class=\"headerlink\" title=\"但是该方法也是有局限性的：\"></a>但是该方法也是有局限性的：</h6><blockquote>\n<p>会忽略 undefined<br>不能序列化函数<br>不能解决循环引用的对象</p>\n</blockquote>\n<hr>\n<p><strong>CommonJS 和 ES6 中的模块化的两者区别</strong>：</p>\n<blockquote>\n<p>前者支持动态导入，也就是require(${path}/xx.js)，后者目前不支持，但是已有提案</p>\n</blockquote>\n<blockquote>\n<p>前者是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响</p>\n</blockquote>\n<blockquote>\n<p>前者在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是后者采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化</p>\n</blockquote>\n<blockquote>\n<p>后者会编译成 require/exports 来执行的</p>\n</blockquote>\n<p><strong>防抖与节流</strong></p>\n<blockquote>\n<p>如果在频繁的事件回调中做复杂计算，很有可能导致页面卡顿，不如将多次计算合并为一次计算，只在一个精确点做操作</p>\n</blockquote>\n<blockquote>\n<p>防抖和节流的作用都是防止函数多次调用。区别在于，假设一个用户一直触发这个函数，且每次触发函数的间隔小于wait，防抖的情况下只会调用一次，而节流的 情况会每隔一定时间（参数wait）调用函数</p>\n</blockquote>\n<blockquote>\n<p>防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行。</p>\n</blockquote>\n<hr>\n<p><strong>解决回调地狱的问题</strong></p>\n<h6 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h6><blockquote>\n<p>Promise看成一个状态机。初始是 pending 状态，可以通过函数 resolve 和 reject ，将状态转变为 resolved 或者 rejected 状态，状态一旦改变就不能再次变化。</p>\n</blockquote>\n<blockquote>\n<p>then 函数会返回一个 Promise 实例，并且该返回值是一个新的实例</p>\n</blockquote>\n<h6 id=\"Generator-实现\"><a href=\"#Generator-实现\" class=\"headerlink\" title=\"Generator 实现\"></a>Generator 实现</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用 * 表示这是一个 Generator 函数</span><br><span class=\"line\">// 内部可以通过 yield 暂停代码</span><br><span class=\"line\">// 通过调用 next 恢复执行</span><br><span class=\"line\">function* test() &#123;</span><br><span class=\"line\">  let a = 1 + 2;</span><br><span class=\"line\">  yield 2;</span><br><span class=\"line\">  yield 3;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let b = test();</span><br><span class=\"line\">console.log(b.next()); // &gt;  &#123; value: 2, done: false &#125;</span><br><span class=\"line\">console.log(b.next()); // &gt;  &#123; value: 3, done: false &#125;</span><br><span class=\"line\">console.log(b.next()); // &gt;  &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure>\n<p><strong>为什么 0.1 + 0.2 != 0.3</strong></p>\n<blockquote>\n<p>因为 JS 采用 IEEE 754 双精度版本（64位），并且只要采用 IEEE 754 的语言都有该问题。<br>我们都知道计算机表示十进制是采用二进制表示的，所以 0.1 在二进制表示为</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// (0011) 表示循环</span><br><span class=\"line\">0.1 = 2^-4 * 1.10011(0011)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>IEEE 754 双精度。六十四位中符号位占一位，整数位占十一位，其余五十二位都为小数位。因为 0.1 和 0.2 都是无限循环的二进制了，所以在小数位末尾处需要判断是否进位（就和十进制的四舍五入一样）。</p>\n</blockquote>\n<blockquote>\n<p>所以 2^-4 <em> 1.10011…001 进位后就变成了 2^-4 </em> 1.10011(0011 <em> 12次)010 。那么把这两个二进制加起来会得出 2^-2 </em> 1.0011(0011 * 11次)0100 , 这个值算成十进制就是 0.30000000000000004</p>\n</blockquote>\n<p><strong>原生解决办法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">parseFloat((0.1 + 0.2).toFixed(10)</span><br></pre></td></tr></table></figure>\n<hr>\n<p><strong>use strict</strong></p>\n<h6 id=\"严格模式优点\"><a href=\"#严格模式优点\" class=\"headerlink\" title=\"严格模式优点\"></a>严格模式优点</h6><blockquote>\n<p>1.减少js代码中不合理的地方，保证js代码的运行安全</p>\n</blockquote>\n<blockquote>\n<p>2.提高编译器的效率</p>\n</blockquote>\n<blockquote>\n<ol start=\"3\">\n<li>为未来js版本做铺垫</li>\n</ol>\n</blockquote>\n<pre><code>// 开启严格模式： 在作用域最上面写上 &apos;use strict&apos;\n// 1.不能使用未声明的变量\n// 2.再严格模式下，函数如果没有调用者，this指向null或者undefined\n// 3.在严格模式下，arguments元素改变， 对应的形参不会改变。\n// 4. 在严格模式下, arguments不可以重新赋值\n// 5. 严格模式下，不可以执行使用八进制\n// 6. 严格模式下不可以使用with语句\n</code></pre><hr>\n<blockquote>\n<p>单进程：一个时间段只能执行一个进程，例如，要听歌就写不了文档</p>\n</blockquote>\n<blockquote>\n<p>多进程：一个时间段能同时执行多个进程，例如，终于能同时听歌写文档了</p>\n</blockquote>\n<blockquote>\n<p>多线程：让一个进程能同时执行一段代码的技术，用起来感觉类似于多进程，但区别在于线程与线程间共享资源，所以比多进程节省了系统资源，例如，一个浏览器可以同时打开两个网页。</p>\n</blockquote>\n<blockquote>\n<p>并发：一个“时间段”有多个程序同时执行，多线程并发和多进程并发应该都算并发，你可以说多进程和多线程是一种技术，并发是一种状态。</p>\n</blockquote>\n<blockquote>\n<p>并行：可以说是微观上的并发或者真正的并发，就是某一个“时刻”有多个程序同时执行，也是一种状态。</p>\n</blockquote>\n<blockquote>\n<p>同步：一个函数调用在没结束前原来的函数啥都不能做，是一种目的。</p>\n</blockquote>\n<blockquote>\n<p>异步：一个函数调用后，原来的函数继续干自己的事情，等那个函数干完后，借助某种手段通知原来的函数执行结果。也是一种目的，一般是通过多线程技术去实现，例：js在遇到ajax时异步调用这个方法，浏览器新建一个线程去处理ajax的事情，js继续干自己的事情，等ajax拿到数据后浏览器将它丢到一个等待队列里面，js干完自己那些不宜中断的事情后就去查询那个队列里面有结果了没，有就拿出来。</p>\n</blockquote>\n","categories":[],"tags":[{"name":"点击更多汇总","path":"api/tags/点击更多汇总.json"}]}