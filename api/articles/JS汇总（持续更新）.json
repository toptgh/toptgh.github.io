{"title":"JS汇总（持续更新）","slug":"JS汇总（持续更新）","date":"2018-10-02T10:18:00.000Z","updated":"2018-12-02T15:33:10.124Z","comments":true,"excerpt":"","content":"<p><strong>webstorage</strong></p>\n<h6 id=\"webstorage是本地存储，存储在客户端，包括localStorage和sessionStorage。\"><a href=\"#webstorage是本地存储，存储在客户端，包括localStorage和sessionStorage。\" class=\"headerlink\" title=\"webstorage是本地存储，存储在客户端，包括localStorage和sessionStorage。\"></a>webstorage是本地存储，存储在客户端，包括localStorage和sessionStorage。</h6><p><strong>localStorage</strong></p>\n<blockquote>\n<p>localStorage生命周期是永久，这意味着除非用户显示在浏览器提供的UI上清除localStorage信息，否则这些信息将永远存在。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。</p>\n</blockquote>\n<p><strong>sessionStorage</strong></p>\n<blockquote>\n<p>sessionStorage仅在当前会话下有效，关闭页面或浏览器后被清除。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信</p>\n</blockquote>\n<h6 id=\"localStorage和sessionStorage使用时使用相同的API\"><a href=\"#localStorage和sessionStorage使用时使用相同的API\" class=\"headerlink\" title=\"localStorage和sessionStorage使用时使用相同的API\"></a>localStorage和sessionStorage使用时使用相同的API</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">localStorage.setItem(&quot;key&quot;,&quot;value&quot;);//以“key”为名称存储一个值“value”</span><br><span class=\"line\"></span><br><span class=\"line\">localStorage.getItem(&quot;key&quot;);//获取名称为“key”的值</span><br><span class=\"line\"></span><br><span class=\"line\">localStorage.removeItem(&quot;key&quot;);//删除名称为“key”的信息。</span><br><span class=\"line\"></span><br><span class=\"line\">localStorage.clear();​//清空localStorage中所有信息</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>不同浏览器无法共享localStorage或sessionStorage中的信息。相同浏览器的不同页面间可以共享相同的 localStorage（页面属于相同域名和端口），但是不同页面或标签页间无法共享sessionStorage的信息。这里需要注意的是，页面及标 签页仅指顶级窗口，如果一个标签页包含多个iframe标签且他们属于同源页面，那么他们之间是可以共享sessionStorage的。</p>\n</blockquote>\n<p><strong>Cookie</strong></p>\n<blockquote>\n<p>生命期为只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。 存放数据大小为4K左右 。有个数限制（各浏览器不同），一般不能超过20个。与服务器端通信：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题</p>\n</blockquote>\n<h6 id=\"localStorage、sessionStorage、Cookie共同点：都是保存在浏览器端，且同源的。\"><a href=\"#localStorage、sessionStorage、Cookie共同点：都是保存在浏览器端，且同源的。\" class=\"headerlink\" title=\"localStorage、sessionStorage、Cookie共同点：都是保存在浏览器端，且同源的。\"></a>localStorage、sessionStorage、Cookie共同点：都是保存在浏览器端，且同源的。</h6><p><strong>如何用原生js给一个按钮绑定两个onclick事件</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var btn4 = document.getElementById(&quot;btn4&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">btn4.addEventListener(&quot;click&quot;,hello1);</span><br><span class=\"line\"></span><br><span class=\"line\">btn4.addEventListener(&quot;click&quot;,hello2);</span><br><span class=\"line\"></span><br><span class=\"line\"> </span><br><span class=\"line\"></span><br><span class=\"line\">function hello1()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> alert(&quot;hello 1&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function hello2()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> alert(&quot;hello 2&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>数组去重</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">方法一：</span><br><span class=\"line\">&lt;!--利用数组的indexOf下标属性来查询。--&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">function unique4(arr)&#123;</span><br><span class=\"line\"> var res = [];</span><br><span class=\"line\"> for(var i=0; i&lt;arr.length; i++)&#123;</span><br><span class=\"line\">  if(res.indexOf(arr[i]) == -1)&#123;</span><br><span class=\"line\">   res.push(arr[i]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> return res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>xml和json的区别，请用四个词语来形容</strong></p>\n<blockquote>\n<p>·  JSON相对于XML来讲，数据的体积小，传递的速度更快些</p>\n</blockquote>\n<blockquote>\n<p>·  JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互</p>\n</blockquote>\n<blockquote>\n<p>·  XML对数据描述性比较好；</p>\n</blockquote>\n<blockquote>\n<p>·  JSON的速度要远远快于XML</p>\n</blockquote>\n<p>ajax(异步javascript xml) 能够刷新局部网页数据而不是重新加载整个网页。</p>\n<p><strong>什么是AJAX</strong></p>\n<blockquote>\n<p>ajax(异步javascript xml) 能够刷新局部网页数据而不是重新加载整个网页</p>\n</blockquote>\n<p><strong>如何使用ajax?</strong></p>\n<blockquote>\n<p>第一步，创建xmlhttprequest对象</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var xmlhttp =new XMLHttpRequest（);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>XMLHttpRequest对象用来和服务器交换数据。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var xhttp;</span><br><span class=\"line\">if (window.XMLHttpRequest) &#123;</span><br><span class=\"line\">//现代主流浏览器</span><br><span class=\"line\">xhttp = new XMLHttpRequest();</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">// 针对浏览器，比如IE5或IE6</span><br><span class=\"line\">xhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>第二步，使用xmlhttprequest对象的open（）和send（）方法发送资源请求给服务器。</p>\n</blockquote>\n<blockquote>\n<p>第三步，使用xmlhttprequest对象的responseText或responseXML属性获得服务器的响应。</p>\n</blockquote>\n<blockquote>\n<p>第四步，onreadystatechange函数，当发送请求到服务器，我们想要服务器响应执行一些功能就需要使用onreadystatechange函数，每次xmlhttprequest对象的readyState发生改变都会触发onreadystatechange函数</p>\n</blockquote>\n<hr>\n<p><strong>undefined 和 null 区别</strong></p>\n<blockquote>\n<p>null： Null类型，代表“空值”，代表一个空对象指针，使用typeof运算得到 “object”，所以你可以认为它是一个特殊的对象值。<br>undefined： Undefined类型，当一个声明了一个变量未初始化时，得到的就是undefined。</p>\n</blockquote>\n<blockquote>\n<p>null是javascript的关键字，可以认为是对象类型，它是一个空对象指针，和其它语言一样都是代表“空值”，不过 undefined 却是javascript才有的。undefined是在ECMAScript第三版引入的，为了区分空指针对象和未初始化的变量，它是一个预定义的全局变量。没有返回值的函数返回为undefined，没有实参的形参也是undefined。</p>\n</blockquote>\n<blockquote>\n<p>javaScript权威指南： null 和 undefined 都表示“值的空缺”，你可以认为undefined是表示系统级的、出乎意料的或类似错误的值的空缺，而null是表示程序级的、正常的或在意料之中的值的空缺。</p>\n</blockquote>\n<hr>\n<p><strong>http 和 https 有何区别？如何灵活使用</strong></p>\n<blockquote>\n<p>http是HTTP协议运行在TCP之上。所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。</p>\n</blockquote>\n<blockquote>\n<p>https是HTTP运行在SSL/TLS之上，SSL/TLS运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。此外客户端可以验证服务器端的身份，如果配置了客户端验证，服务器方也可以验证客户端的身份</p>\n</blockquote>\n<hr>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">常见的HTTP状态码</span><br><span class=\"line\">2开头 （请求成功）表示成功处理了请求的状态代码。</span><br><span class=\"line\"></span><br><span class=\"line\">200   （成功）  服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 </span><br><span class=\"line\">201   （已创建）  请求成功并且服务器创建了新的资源。 </span><br><span class=\"line\">202   （已接受）  服务器已接受请求，但尚未处理。 </span><br><span class=\"line\">203   （非授权信息）  服务器已成功处理了请求，但返回的信息可能来自另一来源。 </span><br><span class=\"line\">204   （无内容）  服务器成功处理了请求，但没有返回任何内容。 </span><br><span class=\"line\">205   （重置内容） 服务器成功处理了请求，但没有返回任何内容。</span><br><span class=\"line\">206   （部分内容）  服务器成功处理了部分 GET 请求。</span><br><span class=\"line\"></span><br><span class=\"line\">3开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</span><br><span class=\"line\"></span><br><span class=\"line\">300   （多种选择）  针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 </span><br><span class=\"line\">301   （永久移动）  请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</span><br><span class=\"line\">302   （临时移动）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</span><br><span class=\"line\">303   （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</span><br><span class=\"line\">304   （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 </span><br><span class=\"line\">305   （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 </span><br><span class=\"line\">307   （临时重定向）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</span><br><span class=\"line\"></span><br><span class=\"line\">4开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。</span><br><span class=\"line\"></span><br><span class=\"line\">400   （错误请求） 服务器不理解请求的语法。 </span><br><span class=\"line\">401   （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 </span><br><span class=\"line\">403   （禁止） 服务器拒绝请求。</span><br><span class=\"line\">404   （未找到） 服务器找不到请求的网页。</span><br><span class=\"line\">405   （方法禁用） 禁用请求中指定的方法。 </span><br><span class=\"line\">406   （不接受） 无法使用请求的内容特性响应请求的网页。 </span><br><span class=\"line\">407   （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。</span><br><span class=\"line\">408   （请求超时）  服务器等候请求时发生超时。 </span><br><span class=\"line\">409   （冲突）  服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 </span><br><span class=\"line\">410   （已删除）  如果请求的资源已永久删除，服务器就会返回此响应。 </span><br><span class=\"line\">411   （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。 </span><br><span class=\"line\">412   （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。 </span><br><span class=\"line\">413   （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 </span><br><span class=\"line\">414   （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。 </span><br><span class=\"line\">415   （不支持的媒体类型） 请求的格式不受请求页面的支持。 </span><br><span class=\"line\">416   （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。 </span><br><span class=\"line\">417   （未满足期望值） 服务器未满足&quot;期望&quot;请求标头字段的要求。</span><br><span class=\"line\"></span><br><span class=\"line\">5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</span><br><span class=\"line\"></span><br><span class=\"line\">500   （服务器内部错误）  服务器遇到错误，无法完成请求。 </span><br><span class=\"line\">501   （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 </span><br><span class=\"line\">502   （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 </span><br><span class=\"line\">503   （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 </span><br><span class=\"line\">504   （网关超时）  服务器作为网关或代理，但是没有及时从上游服务器收到请求。 </span><br><span class=\"line\">505   （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</span><br></pre></td></tr></table></figure>\n<p><strong>如何进行网站性能优化</strong></p>\n<blockquote>\n<ol>\n<li>从用户角度而言，优化能够让页面加载得更快、对用户的操作响应得更及时，能够给用户提供更为友好的体验。</li>\n<li>从服务商角度而言，优化能够减少页面请求数、或者减小请求所占带宽，能够节省可观的资源。\n　　</li>\n</ol>\n</blockquote>\n<h6 id=\"总之，恰当的优化不仅能够改善站点的用户体验并且能够节省相当的资源利用。\"><a href=\"#总之，恰当的优化不仅能够改善站点的用户体验并且能够节省相当的资源利用。\" class=\"headerlink\" title=\"总之，恰当的优化不仅能够改善站点的用户体验并且能够节省相当的资源利用。\"></a>总之，恰当的优化不仅能够改善站点的用户体验并且能够节省相当的资源利用。</h6><blockquote>\n<p>前端优化的途径有很多，按粒度大致可以分为两类</p>\n</blockquote>\n<blockquote>\n<p>第一类是页面级别的优化，例如HTTP请求数、脚本的无阻塞加载、内联脚本的位置优化等;</p>\n</blockquote>\n<blockquote>\n<p>第二类则是代码级别的优化，例如Javascript中的DOM操作优化、CSS选择符优化、图片优化以及HTML结构优化等等。另外，本着提高投入产出比的目的，后文提到的各种优化策略大致按照投入产出比从大到小的顺序排列。</p>\n</blockquote>\n<p>　　一、页面级优化</p>\n<ol>\n<li>JavaScript 压缩和模块打包</li>\n<li>按需加载资源</li>\n<li>在使用 DOM 操作库时用上 array-ids</li>\n<li>缓存</li>\n<li>启用 HTTP/2</li>\n<li>应用性能分析</li>\n<li>使用负载均衡方案</li>\n<li>为了更快的启动时间考虑一下同构</li>\n<li>使用索引加速数据库查询</li>\n<li>使用更快的转译方案</li>\n<li>避免或最小化 JavaScript 和 CSS 的使用而阻塞渲染</li>\n<li>用于未来的一个建议：使用 service workers + 流</li>\n<li>图片编码优化</li>\n</ol>\n<hr>\n<p><strong>react和vue有哪些不同</strong></p>\n<h6 id=\"相同点\"><a href=\"#相同点\" class=\"headerlink\" title=\"相同点\"></a>相同点</h6><p>· 都支持服务器端渲染</p>\n<p>· 都有Virtual DOM,组件化开发,通过props参数进行父子组件数据的传递,都实现webComponent规范</p>\n<p>· 数据驱动视图</p>\n<p>· 都有支持native的方案,React的React native,Vue的weex</p>\n<h6 id=\"不同点\"><a href=\"#不同点\" class=\"headerlink\" title=\"不同点\"></a>不同点</h6><p>· React严格上只针对MVC的view层,Vue则是MVVM模式</p>\n<p>· virtual DOM不一样,vue会跟踪每一个组件的依赖关系,不需要重新渲染整个组件树.而对于React而言,每当应用的状态被改变时,全部组件都会重新渲染,所以react中会需要shouldComponentUpdate这个生命周期函数方法来进行控制</p>\n<p>· 组件写法不一样, React推荐的做法是 JSX + inline style, 也就是把HTML和CSS全都写进JavaScript了,即’all in js’; Vue推荐的做法是webpack+vue-loader的单文件组件格式,即html,css,jd写在同一个文件;</p>\n<p>· 数据绑定: vue实现了数据的双向绑定,react数据流动是单向的</p>\n<p>· state对象在react应用中不可变的,需要使用setState方法更新状态;在vue中,state对象不是必须的,数据由data属性在vue对象中管理</p>\n<hr>\n<p><strong>什么是mvvm mvc是什么区别 原理</strong></p>\n<h6 id=\"MVC（Model-View-Controller）\"><a href=\"#MVC（Model-View-Controller）\" class=\"headerlink\" title=\"MVC（Model-View-Controller）\"></a>MVC（Model-View-Controller）</h6><p>MVC是比较直观的架构模式，用户操作-&gt;View（负责接收用户的输入操作）-&gt;Controller（业务逻辑处理）-&gt;Model（数据持久化）-&gt;View（将结果反馈给View）。</p>\n<p>MVC使用非常广泛，比如JavaEE中的SSH框架</p>\n<h6 id=\"MVVM（Model-View-ViewModel）\"><a href=\"#MVVM（Model-View-ViewModel）\" class=\"headerlink\" title=\"MVVM（Model-View-ViewModel）\"></a>MVVM（Model-View-ViewModel）</h6><p>如果说MVP是对MVC的进一步改进，那么MVVM则是思想的完全变革。它是将“数据模型数据双向绑定”的思想作为核心，因此在View和Model之间没有联系，通过ViewModel进行交互，而且Model和ViewModel之间的交互是双向的，因此视图的数据的变化会同时修改数据源，而数据源数据的变化也会立即反应view。</p>\n<hr>\n<p><strong>eval()的作用</strong></p>\n<h6 id=\"把字符串参数解析成JS代码并运行，并返回执行的结果-产生独立作用域\"><a href=\"#把字符串参数解析成JS代码并运行，并返回执行的结果-产生独立作用域\" class=\"headerlink\" title=\"把字符串参数解析成JS代码并运行，并返回执行的结果,产生独立作用域\"></a>把字符串参数解析成JS代码并运行，并返回执行的结果,产生独立作用域</h6><hr>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eval(&quot;2+3&quot;);//执行加运算，并返回运算值。</span><br></pre></td></tr></table></figure>\n<p><strong>JS哪些操作会造成内存泄露</strong></p>\n<h6 id=\"1）意外的全局变量引起的内存泄露\"><a href=\"#1）意外的全局变量引起的内存泄露\" class=\"headerlink\" title=\"1）意外的全局变量引起的内存泄露\"></a>1）意外的全局变量引起的内存泄露</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function leak()&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">  leak=&quot;xxx&quot;;//leak成为一个全局变量，不会被回收  </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"2）闭包引起的内存泄露\"><a href=\"#2）闭包引起的内存泄露\" class=\"headerlink\" title=\"2）闭包引起的内存泄露\"></a>2）闭包引起的内存泄露</h6><h6 id=\"3）没有清理的DOM元素引用\"><a href=\"#3）没有清理的DOM元素引用\" class=\"headerlink\" title=\"3）没有清理的DOM元素引用\"></a>3）没有清理的DOM元素引用</h6><h6 id=\"4）被遗忘的定时器或者回调\"><a href=\"#4）被遗忘的定时器或者回调\" class=\"headerlink\" title=\"4）被遗忘的定时器或者回调\"></a>4）被遗忘的定时器或者回调</h6><h6 id=\"5）子元素存在引起的内存泄露\"><a href=\"#5）子元素存在引起的内存泄露\" class=\"headerlink\" title=\"5）子元素存在引起的内存泄露\"></a>5）子元素存在引起的内存泄露</h6><hr>\n<p><strong>bootstrap响应式实现的原理</strong></p>\n<h6 id=\"百分比布局-媒体查询\"><a href=\"#百分比布局-媒体查询\" class=\"headerlink\" title=\"百分比布局+媒体查询\"></a>百分比布局+媒体查询</h6><p><strong>什么是闭包，如何使用它，为什么要使用它？</strong></p>\n<blockquote>\n<p>就是能够读取其他函数内部变量的函数。由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。</p>\n</blockquote>\n<blockquote>\n<p>它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中,可以避免全局变量的污染。</p>\n</blockquote>\n<blockquote>\n<p>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p>\n</blockquote>\n<blockquote>\n<p>闭包会在父函数外部，改变父函数内部变量的值。</p>\n</blockquote>\n<p><strong>JSONP的工作原理，以及它为什么不是真正的AJAX</strong></p>\n<blockquote>\n<p>JSONP (JSON with Padding)是一个简单高效的跨域方式，HTML中的script标签可以加载并执行其他域的javascript，于是我们可以通过script标记来动态加载其他域的资源。例如我要从域A的页面pageA加载域B的数据，那么在域B的页面pageB中我以JavaScript的形式声明pageA需要的数据，然后在 pageA中用script标签把pageB加载进来，那么pageB中的脚本就会得以执行。JSONP在此基础上加入了回调函数，pageB加载完之后会执行pageA中定义的函数，所需要的数据会以参数的形式传递给该函数。JSONP易于实现，但是也会存在一些安全隐患，如果第三方的脚本随意地执行，那么它就可以篡改页面内容，截获敏感数据。但是在受信任的双方传递数据，JSONP是非常合适的选择。</p>\n</blockquote>\n<h6 id=\"AJAX是不跨域的，而JSONP是一个是跨域的，还有就是二者接收参数形式不一样！\"><a href=\"#AJAX是不跨域的，而JSONP是一个是跨域的，还有就是二者接收参数形式不一样！\" class=\"headerlink\" title=\"AJAX是不跨域的，而JSONP是一个是跨域的，还有就是二者接收参数形式不一样！\"></a>AJAX是不跨域的，而JSONP是一个是跨域的，还有就是二者接收参数形式不一样！</h6><hr>\n<p><strong>JavaScript的同源策略</strong></p>\n<blockquote>\n<p>同源策略浏览器的保护机制，规定跨域之间的脚本是隔离的，一个域的脚本不能访问和操作另外一个域的绝大部分属性和方法。那么什么叫相同域，什么叫不同的域呢？当两个域具有相同的协议, 相同的端口，相同的host，那么我们就可以认为它们是相同的域。同源策略还应该对一些特殊情况做处理，比如限制file协议下脚本的访问权限。本地的HTML文件在浏览器中是通过file协议打开的，如果脚本能通过file协议访问到硬盘上其它任意文件，就会出现安全隐患，目前IE8还有这样的隐患。</p>\n</blockquote>\n<hr>\n<p><strong>垃圾回收机制方式及内存管理</strong></p>\n<h6 id=\"回收机制方式\"><a href=\"#回收机制方式\" class=\"headerlink\" title=\"回收机制方式\"></a>回收机制方式</h6><p>1、定义和用法：垃圾回收机制(GC:Garbage Collection),执行环境负责管理代码执行过程中使用的内存。</p>\n<p>2、原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function fn1() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    var obj = &#123;name: &apos;hanzichi&apos;, age: 10&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function fn2() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    var obj = &#123;name:&apos;hanzichi&apos;, age: 10&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">   return obj;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;var a = fn1();var b = fn2();</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>fn1中定义的obj为局部变量，而当用结束后，出了fn1的环境，那么该块内存会被js引擎中的垃圾回收器自动释放；在fn2被调用的过程中，返回的对象被全局变量b所指向，所以该块内存并不会被释放。</p>\n</blockquote>\n<h6 id=\"垃圾回收策略：标记清除-较为常用-和引用计数。\"><a href=\"#垃圾回收策略：标记清除-较为常用-和引用计数。\" class=\"headerlink\" title=\"垃圾回收策略：标记清除(较为常用)和引用计数。\"></a>垃圾回收策略：标记清除(较为常用)和引用计数。</h6><p>标记清除：</p>\n<blockquote>\n<p>定义和用法：当变量进入环境时，将变量标记”进入环境”，当变量离开环境时，标记为：”离开环境”。某一个时刻，垃圾回收器会过滤掉环境中的变量，以及被环境变量引用的变量，剩下的就是被视为准备回收的变量。</p>\n</blockquote>\n<blockquote>\n<p>到目前为止，IE、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。</p>\n</blockquote>\n<p>引用计数：</p>\n<blockquote>\n<p>定义和用法：引用计数是跟踪记录每个值被引用的次数。</p>\n</blockquote>\n<blockquote>\n<p>基本原理：就是变量的引用次数，被引用一次则加1，当这个引用计数为0时，被视为准备回收的对象。</p>\n</blockquote>\n<p><strong>浏览器是如何渲染页面的</strong></p>\n<p>1.解析HTML文件，创建DOM树。<br>自上而下，遇到任何样式（link、style）与脚本（script）都会阻塞（外部样式不阻塞后续外部脚本的加载）。</p>\n<p>2.解析CSS。优先级：浏览器默认设置&lt;用户设置&lt;外部样式&lt;内联样式&lt;HTML中的style样式；</p>\n<p>3.将CSS与DOM合并，构建渲染树（Render Tree）</p>\n<p>4.布局和绘制，重绘（repaint）和重排（reflow）</p>\n<p><strong>从输入url到显示页面，都经历了什么</strong></p>\n<p>1、首先，在浏览器地址栏中输入url</p>\n<p>2、浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第三步操作。</p>\n<p>3、在发送http请求前，需要域名解析(DNS解析)(DNS（域名系统，Domain Name System）是互联网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住IP地址。)，解析获取相应的IP地址。</p>\n<p>4、浏览器向服务器发起tcp连接，与浏览器建立tcp三次握手。（TCP即传输控制协议。TCP连接是互联网连接协议集的一种。）</p>\n<p>5、握手成功后，浏览器向服务器发送http请求，请求数据包。</p>\n<p>6、服务器处理收到的请求，将数据返回至浏览器</p>\n<p>7、浏览器收到HTTP响应</p>\n<p>8、读取页面内容，浏览器渲染，解析html源码</p>\n<p>9、生成Dom树、解析css样式、js交互</p>\n<p>10、客户端和服务器交互</p>\n<p>11、ajax查询</p>\n<hr>\n<p><strong>JavaScript中如何检测一个变量是一个String类型？</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typeof(obj) === &quot;string&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">typeof obj === &quot;string&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.constructor === String</span><br></pre></td></tr></table></figure>\n<p><strong>判断一个字符串中出现次数最多的字符，统计这个次数</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &apos;asdfssaaasasasasaa&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">var json = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">for (var i = 0; i &lt; str.length; i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    if(!json[str.charAt(i)])&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       json[str.charAt(i)] = 1;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       json[str.charAt(i)]++;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;var iMax = 0;var iIndex = &apos;&apos;;for(var i in json)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    if(json[i]&gt;iMax)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">         iMax = json[i];</span><br><span class=\"line\"></span><br><span class=\"line\">         iIndex = i;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;        console.log(&apos;出现次数最多的是:&apos;+iIndex+&apos;出现&apos;+iMax+&apos;次&apos;);</span><br></pre></td></tr></table></figure>","categories":[],"tags":[{"name":"汇总|点击更多","path":"api/tags/汇总|点击更多.json"}]}