{"title":"什么是模块化开发","slug":"模块化开发","date":"2018-10-21T10:58:00.000Z","updated":"2018-12-06T06:28:32.181Z","comments":true,"excerpt":"","content":"<h2 id=\"没有前戏，简明扼要的进入主题——什么是模块化开发\"><a href=\"#没有前戏，简明扼要的进入主题——什么是模块化开发\" class=\"headerlink\" title=\"没有前戏，简明扼要的进入主题——什么是模块化开发\"></a>没有前戏，简明扼要的进入主题——什么是模块化开发</h2><p>模块化开发，一个模块就是一个实现特定功能的文件，有了模块我们就可以更方便的使用别人的代码，要用什么功能就加载什么模块。</p>\n<p><strong>模块化开发的4点好处：</strong></p>\n<p>　　1 避免变量污染，命名冲突</p>\n<p>　　2  提高代码复用率</p>\n<p>　　3 提高维护性</p>\n<p>　　4 依赖关系的管理</p>\n<p>前端模块化规范从原始野蛮阶段现在慢慢进入“文艺复兴”时代，实现的过程如下：</p>\n<p><strong>一 函数封装</strong></p>\n<p>我们在讲到函数逻辑的时候提到过，函数一个功能就是实现特定逻辑的一组语句打包，在一个文件里面编写几个相关函数就是最开始的模块了</p>\n<p>function m1(){　　　　//…　　}　　function m2(){　　　　//…　　}</p>\n<p>这样做的缺点很明显，污染了全局变量，并且不能保证和其他模块起冲突，模块成员看起来似乎没啥关系</p>\n<p><strong>二 对象</strong></p>\n<p>为了解决这个问题，有了新方法，将所有模块成员封装在一个对象中</p>\n<p>var module = new Object({   _count:0,   m1:function (){  <code>},   m2:function (){</code>  }                  })    </p>\n<p>这样 两个函数就被包在这个对象中， 嘿嘿 看起来没毛病是吗 继续往下：</p>\n<p>当我们要使用的时候，就是调用这个对象的属性</p>\n<p>module.m1()</p>\n<p>诶嘿 那么问题来了 这样写法会暴露全部的成员，内部状态可以被外部改变，比如外部代码可直接改变计数器的值</p>\n<p>//坏人的操作module._count = 10;</p>\n<p>最后的最后，聪明的人类找到了究极新的方法——立即执行函数，这样就可以达到不暴露私有成员的目的</p>\n<p>var module = (function (){    var _count = 5;         var m1 = function (){  <code>};    var m2 = function (){</code>   };    return{         m1:m1,         m2:m2    }})()    </p>\n<p>以上就是模块化开发的基础中的基础，以后会说道其他更深层次的模块化开发。</p>\n<p>接下来了解一下两种模块化规范。</p>\n<p>先了解一下commonJS。</p>\n<p>commonJS由nodeJS发扬光大，这标志着js模块化正式登场。</p>\n<p><strong>一 定义模块</strong></p>\n<p>根据commonJS规范，一个单独的文件是一个模块，每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非为global对象的属性。</p>\n<p><strong>二 模块输出 </strong></p>\n<p>模块只有一个出口，module.exports对象，我们需要把模块希望输出的内容放入该对象。</p>\n<p><strong>三 加载模块</strong></p>\n<p>加载模块用require方法，该方法读取一个文件并且执行，返回文件内部的module.exports对象。</p>\n<p>var name = ‘Byron’;    function printName(){      console.log(name);  }    function printFullName(firstName){      console.log(firstName + name);  }    module.exports = {      printName: printName,      printFullName: printFullName  </p>\n<p>然后加载模块</p>\n<p>var nameModule = require(‘./myModel.js’);nameModule.printName();</p>\n<p>AMD</p>\n<p>Asynchronous Module Definition，中文名是一步模块。它是一个在浏览器端模块化开发的规范，由于不是js原生支持，使用AMD规范进行页面开发需要用到对应的函数库，也就是大名鼎鼎的RequireJS，实际上AMD是RequireJS在推广过程中对模块定义的规范化的产出。</p>\n<p><strong>requireJS主要解决两个问题</strong>：</p>\n<p>1 多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器。</p>\n<p>2 js加载的时候浏览器会停止页面渲染，加载文件愈多，页面失去响应的时间愈长。</p>\n<p>//定义模块define([‘dependency’],function(){    var name = ‘Byron’;  function printName(){     console.log(name);}    return {     printName:printName   }})//加载模块require([‘myModule’],function(my){   my.printName();})</p>\n<p>语法：</p>\n<p>requireJS定义了一个函数define，它是全局变量，用来定义模块。</p>\n<p>define(id,dependencies,factory)</p>\n<p>——id  可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名）</p>\n<p>——dependencies  是一个当前模块用来的模块名称数组</p>\n<p>——factory 工厂方法，模块初始化要执行的函数或对象，如果为函数，它应该只被执行一次，如果是对象，此对象应该为模块的输出值。</p>\n<p>在页面上使用require函数加载模块；</p>\n<p>require([dependencies], function(){});</p>\n<p>require()函数接受两个参数：</p>\n<p>——第一个参数是一个数组，表示所依赖的模块；</p>\n<p>——第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块</p>\n<p>AMD推崇的是依赖前置，被提前罗列出来并会背提前下载并执行，后来做了改进，可以不用罗列依赖模块，允许在回调函数中就近使用require引入并下载执行模块。</p>\n<p>==CMD==</p>\n<p>即common module definition</p>\n<p>就像AMD有个requireJS,CMD有个浏览器实现的sea.js，sj要解决的问题和rj一样，只不过在模块定义方式和模块加载时机上有所不同。</p>\n<p>cmd是sea.js在推广过程中的规范化产出，sea.js是另一种前端模块化工具，它的出现缓解了requireJS的几个痛点。</p>\n<p>define(id, deps, factory)</p>\n<p>因为CMD推崇一个文件一个模块，所以经常就用文件名作为模块id；</p>\n<p>CMD推崇依赖就近，所以一般不在define的参数中写依赖，而是在factory中写。</p>\n<p>factory有三个参数：function(require, exports, module){}</p>\n<p>一，requirerequire 是 factory 函数的第一个参数，require 是一个方法，接受 模块标识 作为唯一参数，用来获取其他模块提供的接口；</p>\n<p>二，exportsexports 是一个对象，用来向外提供模块接口；</p>\n<p>三，modulemodule 是一个对象，上面存储了与当前模块相关联的一些属性和方法。demo// 定义模块  myModule.jsdefine(function(require, exports, module) {  var $ = require(‘jquery.js’)  $(‘div’).addClass(‘active’);});// 加载模块seajs.use([‘myModule.js’], function(my){});</p>\n<p><strong>AMD与CMD区别</strong></p>\n<p>总结如下：</p>\n<p>最明显的区别就是在模块定义时对依赖的处理不同。</p>\n<p>AMD推崇依赖前置 在定义模块的时候就有声明其依赖的模块</p>\n<p>CMD推崇就近依赖 只有在用到某模块的时候再去require</p>\n<p>AMD和CMD最大的区别是对依赖模块的执行时机处理不同，注意不是加载的时机或者方式不同。</p>\n<p>很多人说requireJS是异步加载模块，SeaJS是同步加载模块，这么理解实际上是不准确的，其实加载模块都是异步的，只不过AMD依赖前置，js可以方便知道依赖模块是谁，立即加载，而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略。</p>\n<p>为什么我们说两个的区别是依赖模块执行时机不同，为什么很多人认为ADM是异步的，CMD是同步的（除了名字的原因。。。）</p>\n<p>同样都是异步加载模块，AMD在加载模块完成后就会执行改模块，所有模块都加载执行完后会进入require的回调函数，执行主逻辑，这样的效果就是依赖模块的执行顺序和书写顺序不一定一致，看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行。</p>\n<p>CMD加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到require语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的。</p>\n<p>这也是很多人说AMD用户体验好，因为没有延迟，依赖模块提前执行了，CMD性能好，因为只有用户需要的时候才执行的原因。      </p>\n","categories":[],"tags":[{"name":"点击更多笔记","path":"api/tags/点击更多笔记.json"}]}