{"title":"ES6笔记","slug":"ES6","date":"2017-10-06T10:58:00.000Z","updated":"2018-12-02T15:31:15.457Z","comments":true,"excerpt":"","content":"<pre>\npromise：\n\n//执行时先输出同步的，异步在最后输出\nconst promise =new Promise(（resolve,reject）=>{}）\nresolve或者reject只能有一个结果 如果是resolve那么reject就不执行了 并且resolve只能执行一次\n.then(Promise.resolve(3))\nthen 方法接受的参数是函数，而如果传递的并非是一个函数，它实际上会将其解释为 then(null)，这就会导致前一个 Promise 的结果会穿透下面。\n\n// 异步处理\n    处理成功。调用手动resolve\n    处理失败。调用手动reject\n    代码错误，自动调用reject\n\n//使用场景\n    多个回调嵌套 （回调地狱：函数层层嵌套）\n    多个模块之间，需要异步处理后传值\n\n// 第一步，第二步，都是异步处理。并且需要依次执行\nnew Promise((resolve, reject)=>{\n    console.log('第一步');\n    resolve();\n})\n.then(()=>{\n    return new Promise((resolve, reject)=>{\n        console.log('第二步');\n        resolve();\n    })\n})\n\n// 第一步，第二步，第三步，都是异步处理。并且需要同时执行，却要获得最终结果\nPromise.all([p1, p2, p3]) \n.then(()=>{})\t//不管成功还是失败都会输出全部结果\n\nPromise.race([p1, p2, p3])\n.then(()=>{})\t// 并发异步操作,谁先完成结果就是谁的\n\n\n\n\n字符串：\n//查找：返回布尔值 必须开头字符串顺序一样才是true\nstr.startsWith('') 开头查找 \nstr.endsWith('')  尾部查找\nstr.includes('') 全部包含\n\n//模板字符串：可以包含回车，变量以'${}'插入，可读性高\n`${}`    \n'\\' 不保留空格回车，拼接成一行\n`` 保留空格回车，保持原样\n\n数组：\n// 数组解构\n// 按数组下标解构，如果超出数组长度，为undefined\nlet arr = [1,2,3,4];\nlet [a1, a2, a3, a4] = arr; //[1,2,3,4]  a1等不是数组而是相当于声明了一个变量 \n\n//数组扩展运算符 数组深拷贝\n(...arr) //1,2,3,4 去掉[] 逗号保留\n\n// 数组新增的方法\nmap循环遍历 item为元素 index为索引， return 元素和索引， 返回元素和索引\nlet arr=arr.map((item,index)=>{}) \n\nfind 遍历查找需要的值 ，return 条件语句 找到只返回一个值，后面不查找\nlet arr=arr.find((item,index)=>{}) 返回需要的item \nlet arr=arr.findIndex((item,index)=>{})  返回需要的index\n\nfilter 过滤\nlet arr=arr.filter((item,index)=>{}) 返回符合的值\n\n对象：\n// 拷贝多个对象的属性： \n1.Object.assign（）对象深拷贝\n2.JSON.parse(JSON.stringify())\n3{...}\n参数1：目标对象，其他参数：源对象\n返回值：目标对象\n// 将多个对象的值合并给第一对象，属性如果有重复的，后面的值会覆盖前面的\nlet result = Object.assign( {}，obj1, obj2, obj3);\n\n// 对象简写方式\n对象的键和值一样时。可以写成一个 name:name写成name\n\n函数：\n//箭头函数:\n标准：var add=(a,b)=>{return a+b}\n函数体里只有一个return时简写：var add=(a,b)=>(a+b)\n只有一个形参时：var add=a=>{}\n多个参数，没有参数都不能省略()：var add=()=>{}\n\n// 箭头函数this指向上下文\n// 普通函数谁调用指向谁\n// 箭头函数通常用于回调函数\n\n// 函数的剩余参数：...rest\nfunction testFun(name, age, ...rest){\n    console.log(rest);\t//['c','d']\n    console.log(name);//a\n    console.log(age);//b\n}\ntestFun('a', 'b', 'c', 'd');\n\n\nClass:\n//类方法Object.assgin  Array.from    对象方法arr.map  arr.find\n//声明一个类\nclass Person{\n    // 构造函数\n    constructor(name){\n        //this指向类创建的实例对象\n        this.name = name;\n    }\n    say(){\n        console.log(`my name is ${this.name}`);\n    }\n}\n//实例对象\nlet zhangsan = new Person('张三'); \n\n\n// 继承\nclass Man extends Person{\n    //继承得到父类的所以属性和方法(类方法对象方法都可以继承)\n    //默认指向父类的：\n     constructor(name){\n        super(name);  //重写了构造函数，必须调用super\n     }\n\n}\n\nlet：只能在当前代码块里面使用\n{代码块 }\n\n\nES6模块化：\n// es6默认输出内容：export default{}\n\n//es6引入默认模块：import person from './person'\n\n// 修改引入指定输出的内容的名字\nimport {obj as object, str as string} from './a'\n\n//各种类型输出(推荐使用)\nexport default{}\nlet obj={}\nexport let boo=true\n...\nexport {\n    obj,\n    str,\n    number,\n    testCFunc,\n    num\n}\n//引入各种类型输出\nimport cDefault, {obj, testCFunc as func, boo as bo} from './c'\n\n//引入全部\nimport * as cModule from './c'\n</pre>","categories":[],"tags":[{"name":"笔记|点击更多","path":"api/tags/笔记|点击更多.json"}]}